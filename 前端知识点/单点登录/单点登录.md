# 简介 #
单点登录 SSO，简洁一点的说，就是在一个多系统共存的环境下，用户的一次登录，就能得到其他所有系统的信任。

单点登录在大型网站里使用得非常频繁，例如像阿里巴巴这样的网站，在网站的背后是成百上千的子系统，用户一次操作或交易可能涉及到几十个子系统的协作，如果每个子系统都需要用户认证，不仅用户会疯掉，各子系统也会为这种重复认证授权的逻辑搞疯掉。

实现单点登录，说到底就是要解决两个问题：

1. 如何存储信任
2. 如何验证信任

单点登录有很多种实现方式，下面可以从简单、不安全到复杂、安全的角度一一介绍下：


## 以 Cookie 作为凭证媒介 ##
最简单的单点登录方式，就是使用客户端 Cookie 作为媒介存放用户登录凭证。用户登录父应用后，父应用返回一个加密过的 cookie 存放在客户端中，当用户访问子应用的时候，携带上这个 cookie，授权应用解密 cookie 并进行校验，校验通过则登录当前用户。

![img1](https://upload-images.jianshu.io/upload_images/79702-b33138a8d24fc12b.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1000/format/webp)

不过上面方式用两个问题：

1. cookie 存放在客户端不安全
2. cookie 不能跨域访问

对于第一个问题，可以通过对 cookie 进行严格加密来提高安全度（当然前提是 cookie 的加密算法不泄露，不然也是很危险的）。而第二个问题就没法解决了，因为这是硬伤。


## 通过 JSONP 实现 ##
对于跨域问题，可以使用 JSONP 实现。

用户在父应用中登录后，跟 Session 匹配的 Cookie 会存到客户端中，当用户需要登录子应用的时候，授权应用访问父应用提供的 JSONP 接口（注意这里是父应用提供的jsonp方法），并在请求中带上父应用域名下的 Cookie，父应用接收到请求，验证用户的登录状态，返回加密的信息，子应用通过解析返回来的加密信息来验证用户，如果通过验证则登录用户。

![img2](https://upload-images.jianshu.io/upload_images/79702-7ddba46df098374b.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1000/format/webp)

这种方式虽然能解决跨域问题，但是安全性其实跟把信任存储到Cookie是差不多的。如果一旦加密算法泄露了，攻击者可以在本地建立一个实现了登录接口的假冒父应用，通过绑定Host来把子应用发起的请求指向本地的假冒父应用，并作出回应。

因为攻击者完全可以按照加密算法来伪造响应请求，子应用接收到这个响应之后一样可以通过验证，并且登录特定用户。


## 通过页面重定向的方式 ##
最后一种介绍的方式，是通过父应用和子应用来回重定向中进行通信，实现信息的安全传递。

父应用提供一个GET方式的登录接口，用户通过子应用重定向连接的方式访问这个接口，如果用户还没有登录，则返回一个的登录页面，用户输入账号密码进行登录。如果用户已经登录了，则生成加密的Token，并且重定向到子应用提供的验证Token的接口，通过解密和校验之后，子应用登录当前用户。

![img3](https://upload-images.jianshu.io/upload_images/79702-6409eeef6e923407.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1000/format/webp)

这种方式较前面两种方式，接解决了上面两种方法暴露出来的安全性问题和跨域的问题，但是并没有前面两种方式方便。


# 使用独立登录系统（SSO） #
这种方式是目前比较流行的安全的单点登录方式。一般说来，大型应用会把授权的逻辑与用户信息的相关逻辑独立成一个应用，称为用户中心。

用户中心不处理业务逻辑，只是处理用户信息的管理以及授权给第三方应用。第三方应用需要登录的时候，则把用户的登录请求转发给用户中心进行处理，用户处理完毕返回凭证，第三方应用验证凭证，通过后就登录用户。

![img4](https://yqfile.alicdn.com/721f02ebe06639e6232b59535d6423db75086693.png)

如图所示，图中有4个系统，分别是 Application1、Application2、Application3、和 SSO。

Application1、Application2、Application3 没有登录模块，而 SSO 只有登录模块，没有其他的业务模块，当 Application1、Application2、Application3 需要登录时，将跳到 SSO 系统，SSO 系统完成登录，其他的应用系统也就随之登录了。


## 同域下的单点登录 ##
一个企业一般情况下只有一个域名，通过二级域名区分不同的系统。比如我们有个域名叫做：a.com，同时有两个业务系统分别为：app1.a.com和app2.a.com。我们要做单点登录（SSO），需要一个登录系统，叫做：sso.a.com。

我们只要在sso.a.com登录，app1.a.com和app2.a.com就也登录了。通过上面的登陆认证机制，我们可以知道，在sso.a.com中登录了，其实是在sso.a.com的服务端的session中记录了登录状态，同时在浏览器端（Browser）的sso.a.com下写入了Cookie。

那么我们怎么才能让app1.a.com和app2.a.com登录呢？这里有两个问题：

1. Cookie是不能跨域的，我们Cookie的domain属性是sso.a.com，在给app1.a.com和app2.a.com发送请求是带不上的。
2. sso、app1和app2是不同的应用，它们的session存在自己的应用内，是不共享的。

那么我们如何解决这两个问题呢？针对第一个问题，sso登录以后，可以将Cookie的域设置为**顶域**，即.a.com，这样所有子域的系统都可以访问到顶域的Cookie。

Cookie的问题解决了，我们再来看看session的问题。我们在sso系统登录了，这时再访问app1，Cookie也带到了app1的服务端（Server），app1的服务端怎么找到这个Cookie对应的Session呢？这里就要把3个系统的Session共享，如图所示：

![img5](https://yqfile.alicdn.com/4e31c204eea22ee07154df928a5ff5350da03d7a.png)

这样同域下的单点登录就实现了。


## 不同域下的单点登录 ##
同域下的单点登录是巧用了 Cookie 顶域的特性已经 Session 的共享机制。如果是不同域呢？不同域之间 Cookie 是不共享的，怎么办？

这里我们就要说一说 CAS 流程了，这个流程是单点登录的标准流程：

(SSO 是单点登录域，所有关于用户信息验证的东西都在这里完成，不涉及其他业务逻辑)

![img6](https://yqfile.alicdn.com/dcb743204f8a201be53df5338fc34affe5fa1059.png)

上图是CAS官网上的标准流程，具体流程如下：

1. 用户访问app1系统，app1系统是需要登录的，但用户现在没有登录。
2. 跳转到CAS server，即SSO登录系统，以后图中的CAS Server我们统一叫做SSO系统。 SSO系统也没有登录，弹出用户登录页。
3. 用户填写用户名、密码，SSO系统进行认证后，将登录状态写入SSO的session，浏览器（Browser）中写入SSO域下的Cookie。
4. SSO系统登录完成后会生成一个ST（Service Ticket），然后跳转到app1系统，同时将ST作为参数传递给app1系统。
5. app1系统拿到ST后，从后台向SSO发送请求，验证ST是否有效。
6. 验证通过后，app1系统将登录状态写入session并设置app1域下的Cookie。

至此，跨域单点登录就完成了。以后我们再访问app1系统时，app1就是登录的。接下来，我们再看看访问app2系统时的流程。

1. 用户访问app2系统，app2系统没有登录，跳转到SSO。
2. 由于SSO已经登录了，不需要重新登录认证。
3. SSO生成ST，浏览器跳转到app2系统，并将ST作为参数传递给app2。
4. app2拿到ST，后台访问SSO，验证ST是否有效。
5. 验证成功后，app2将登录状态写入session，并在app2域下写入Cookie。

这样，app2系统不需要走登录流程，就已经是登录了。SSO，app和app2在不同的域，它们之间的session不共享也是没问题的。

有的同学会问，SSO系统登录后，跳回原业务系统时，带了个参数ST，业务系统还要拿ST再次访问SSO进行验证，觉得这个步骤有点多余。他想SSO登录认证通过后，通过回调地址将用户信息返回给原业务系统，原业务系统直接设置登录状态，这样流程简单，也完成了登录，不是很好吗？

其实这样问题时很严重的，如果我在SSO没有登录，而是直接在浏览器中敲入回调的地址，并带上伪造的用户信息，是不是业务系统也认为登录了呢？这是很可怕的。

**单点登录，资源都在各个业务系统这边，不在SSO那一方。 用户在给SSO服务器提供了用户名密码后，作为业务系统并不知道这件事。 SSO随便给业务系统一个ST，那么业务系统是不能确定这个ST是用户伪造的，还是真的有效，所以要拿着这个ST去SSO服务器再问一下，这个用户给我的ST是否有效，是有效的我才能让这个用户访问**
