# 分布式和集中式的版本控制的区别 #
> 先说集中式版本控制系统，版本库是集中存放在中央服务器的，而干活的时候，用的都是自己的电脑，所以要先从中央服务器取得最新的版本，然后开始干活，干完活了，再把自己的活推送给中央服务器。中央服务器就好比是一个图书馆，你要改一本书，必须先从图书馆借出来，然后回到家自己改，改完了，再放回图书馆。集中式版本控制系统最大的毛病就是必须联网才能工作，如果在局域网内还好，带宽够大，速度够快，可如果在互联网上，遇到网速慢的话，可能提交一个10M的文件就需要5分钟。
> 
> 那分布式版本控制系统与集中式版本控制系统有何不同呢？首先，分布式版本控制系统根本没有“中央服务器”，每个人的电脑上都是一个完整的版本库，这样，你工作的时候，就不需要联网了，因为版本库就在你自己的电脑上。既然每个人电脑上都有一个完整的版本库，那多个人如何协作呢？比方说你在自己电脑上改了文件A，你的同事也在他的电脑上改了文件A，这时，你们俩之间只需把各自的修改推送给对方，就可以互相看到对方的修改了。
> 
> 和集中式版本控制系统相比，分布式版本控制系统的安全性要高很多，因为每个人电脑里都有完整的版本库，某一个人的电脑坏掉了不要紧，随便从其他人那里复制一个就可以了。而集中式版本控制系统的中央服务器要是出了问题，所有人都没法干活了。

<p>集成式</p>
![集成式](http://www.nowamagic.net/librarys/images/201401/2014_01_03_06.jpg)

<p>分布式</p>
![分布式](http://www.nowamagic.net/librarys/images/201401/2014_01_03_07.jpg)

**用比较通俗的语言总结一下：**<br>
**集成式：**就相当于一个图书馆，所有人都必须先从图书馆借书才能看，如果你修改了书中的内容，别人又想看到你修改的地方，那你必须先把书还回去，别人在把你还回去的书再借到，才能看到你的修改。如果这个图书馆被大火烧掉了，那所有人都没书可看<br>
**分布式：**每个人家里都有一个相同的图书馆，自己拿自己借，自己改。别人如果想看你修改了的书的内容，你只需要把书复制一份到一个公共的平台上（比如githup），别人可以从那里直接在复制到自己的图书馆中。如果有一个人家里着火了，图书都烧没了，他如果把火处理后还想拥有那些全部书籍的话，只需要重其他人那里拷贝一份或者重一个公共的平台上（比如githup）上，把所有的书重新复制一份到自己家里就可以了。


# 什么是git？ #
> git是一个免费的并且开源的 "分布式" "版本控制" 系统

- 分布式：每一台电脑都相当于版本库，即使没有网络也一样可以Commit提交，查看历史版本记录，创建项 目分支等操作，等网络再次连接上Push到Server端
- 版本控制：保留文件所有的修改历史记录，可以方便地撤销之前对文件的修改操作


## 安装git注意点（windows系统上） ##
1. 在Select Components 面板：除了最后一个 Check daily for ...（每天检查Git是否有windows更新） 不需要勾选外，其他都勾上
2. Choosing this default...面板上：可以选择勾选 Use Vim 作为git的默认编辑器
3. Adjusting your PATH...面板（配置Path环境）：除了 Use Git bash only 外其他都可以勾上
4. Choosing HTTPS transport backend（选择https传输协议）：勾选 Use the OpenSSL library
5. Configuring the line...（配置行结束转换）：选择 Checkout windows-style commit Unix-style line endings
6. Configuring the terminal...：勾选 Use MimTTY...
7. Configuring cxtra optings（配置额外选项）：勾选 Enable file system caching 和 Enable Git Credential Manager 这两个


## git常用命令上手操作 ##
> 输入 git 命令工具的时候你如果忘记了指令名称，你可以在输入一半的时候，按tab键搜索相关指令

- git init：初始化创建仓库，会生成一个隐藏的文件夹".git"，这个文件夹将保持你的操作记录
- git status：查看当前仓库所在目录的文件状态（未被git追踪、文件修改、删除等）
- git add：让git去主动追踪你要管理的文件，可以是单个文件(git add a.html)，也可以是整个目录所有文件(git add .)
- git commit -am "描述文字"：提交的描述 
- git log：打印操作日志


## git add 到底做了什么？ ##
> 可以注意到，对之前你对一个文件或者整个目录已经做了git add 的时候，你对某个文件的每一次修改，并且提交前都需要重新做一次 git commit 的操作，也就是说，你对文件的每一次操作，在提交的时候，都需要先 git add 一次，然后在 git commit 才能提交上去，这是为什么呢？这里就涉及到git的三种文件状态和三个工作区域，在提交之前，都会先去一个叫做git暂存区域的地方去查看对应的提交文件，而commit就是去暂存区域查看对应提交文件的指令（git add 的操作就是把文件加入到暂存区）

- 文件的三种状态：已修改、已暂存、已提交
- 三个工作区域：工作目录、暂存区域、版本库
- Git工作流程：
	1. 在工作目录中修改文件
	2. 暂存文件
	3. 提交更新，找到暂存区文件

## git的工作流程 ##
> 分布式和集成式对于工作流程有一个很大的不同点，就是集成式（比如svn）中没有暂存这个概念，你在本地开发完后可以直接提交到你的库中。而分布式则不同，你本地开发完后要先提交到暂存区中，然后在提交到版本库中，在这个暂存区可以处理很多你代码上的问题，比如误操作、创建分支、分步提交等等。

- 工作区：你的本地代码
- 暂存区：你写好的代码不能直接提交到仓库中，需要先提交到暂存区
- 版本库：所有项目版本代码存放的地方

1. git clone 项目地址（可以在这一步设置贡献者）
2. git status：查看目录或文件修改状态
3. git add .：将修改的文件添加到暂存区
4. git commit -m '文件描述'：对提交文件的描述
5. git push origin 要提交的分支：提交到gitHup或者gitLab仓库中的哪个分支下
6. git log：打印你的提交日志

**设置项目贡献者**<br>
> 让其他人在克隆这个项目的时候知道是谁创建的这个项目，叫什么名字等信息

- git clone 项目地址：克隆githup上的项目
- git config --global user.name '用户名'：设置用户名
- git config --global user.email '邮箱'：设置邮箱地址
- git config --list：查看全局所有配置


## git 指令扩展 ##
- git add .：添加所有改动文件及未追踪文件
- git config --global core.quotepath false：解决对应中文文件名称添加到暂存区域时用 git status 查看暂存区状态的时候出现的乱码情况
- git commit -m '描述文字'：合并提交和描述，一步完成操作（如果只进行git commit git界面会进入vim默认，这个默认不方便操作）
- git commit -am '描述文字'：如果只对一个已经被git追踪过的文件反复修改，并且提交的时候，每次都要进行 git add . 操作很麻烦，可以用这个；从工作目录提交到暂存区后，直接提交


## 删除文件（本地仓库和git暂存仓库） ##
- git rm 文件名：同时删除本地目录的文件和git暂存区的文件
- git rm --cache 文件名：只删除git暂存区的文件，让它未被git追踪，也就不会被提交
- git rm -f 文件名：强制删除本地仓库和git暂存区仓库的某个文件，出现这步操作的情况是你已经把这个文件添加进了git暂存区，但之后你有做了修改，然后你不想要了，又去rm删除它，这时候就会出现异常


## 移动文件 ##
- git mv 原文件名 移动或重命名的文件名：在本地仓库中重命名文件或者移动文件，在git提交的时候都需要add一次，如果你想直接通过git去重命名和移动文件，而不需要在执行add操作，可以使用这个 git指令；这样这个移动或者重命名的文件依然会被git追踪到


## status -s 查看所有文件状态（绿色表示在暂存区中，红色不在暂存区中） ##
- ??：未追踪文件
- A：添加到暂存区的文件
-  M：被修改但未进入暂存区的文件
- MM：修改后放入暂存区，并且之后又再次修改的文件
- M ：被修改后放入暂存区
- D：被删除文件
- R：重命名文件


## 文件比较 diff ##
> 本地工作目录文件与git暂存区中对应文件的比较（如果打印了乱码，是因为你的文件编码不是 UTF-8 ）
> 
>----表示你之前在暂存区中的内容，++++表示你修改后的内容，但没有在暂存区中（里面的-1，或者+1中的数字1表示改动的代码行号） 

- git diff：本地仓库工作去和git暂存区所有文件的差异比较
- git diff 文件名：指定某个文件的比较
- git diff --staged：暂存区和提交之后的所有文件比较
- git diff --staged 文件名：指定某个文件暂存区和提交之后的文件比较
- git diff master：工作区代码和master分支代码的比较


## 分支的操作 ##
> 注意在切换分支的时候，你的本地仓库的所有文件都是跟随分支里面的一个叫做“分叉”路径去指向的，工作目录所有的文件也都会恢复到当前分支的快照中

- git branch：查看本地仓库分支
- git branch 分支名：本地仓库创建分支
- git checkout -b 分支名：本地仓库创建分支，并切换到新创建的分支
- git checkout 分支名：切换本地仓库分支
- git branch -d 分支名：删除本地分支(不能删除没有通过 merge 合并过的分支)
- git branch -D 分支名：删除本地分支（强制删除，即使该分支没有通过 merge 合并过）


## 什么是master分支？ ##
> Git 的分支本质上仅仅是指向提交对象的一个可变指针，在本地仓库使用 git init 初始化本地仓库时，默认会指向 master 分支，在你的所有项目中，master分支是最重要的，你线上的版本就是master的版本，所以我们经常会听到要改一个版本时，先让你创建一个新的分支，然后改完需求、测试通过后，在去把这个分支提交，然后合并到master上，然后在由服务端把master分支发布线上


## 更新分支代码 ##
> 多人协作，解决冲突

**把远程的分支代码拉取到本地，但不和你的代码合并，然后通过手动去合并代码，解决冲突**
<p>这种情况多用在本地代码开发完了，在提交到分支之前，为了减少与线上master分支的冲突时（因为你的分支最终还是会合并到master上）</p>
1. git fetch：拉取远程代码，但不合并
2. git diff master origin/master：可以比较下远程代码和你本地代码的异同
3. git rebase origin/master：合并代码
4. 找到对应的代码，解决冲突
5. git add -u
6. git rebase --continue
7. 经过上面的操作后，你提交的最终分支代码和master上就没有冲突了，最后进行 master 合并你提交的分支代码时，就不会在出现冲突了

**把远程分支代码拉取到本地，不直接合并代码，需要手动解决冲突**
<p>在多人协作开发一个分支，并且多个人开发同一个板块时（别人会碰你的模块代码），在你提交本地代码前，先执行fetch操作，保证代码没有冲突，如果有，就要与那个人进行商量，看谁的代码要保留</p>
1. git fetch：拉取远程代码，但不合并
2. git diff 分支名 origin/分支名：可以比较下代码的异同
3. git 分支名 origin/分支名：合并代码
4. 找到对应的代码，解决冲突

**把远程分支代码拉取到本地，然后直接合并代码**
<p>在多人协作开发一个分支，并且每个人开发不同板块时（别人不会碰你的模块代码），在你提交本地代码前，先执行pull操作，保证分支代码一致</p>
- git pull origin 分支名：把远程分支代码拉取到本地


## 分支合并 ##
- git merge 要合并的分支
- git merge --abort
- git log --oneline --decorate：打印当前分支的所有提交及合并等操作
- git log --oneline --decorate --all --graph：在当前分支打印所有分支的提交及合并等操作，并形成树形图解

## 合并分支冲突的产生 ##
- master 和 feature 分支如果处于同一个条commit路径上（直接级祖先关系），它不会引起冲突，而是直接合并
- master 和 feature 分支如果不处于同一个条commit路径上，如果修改一致不会引起冲突；如果不一致，是否修改同一个文件内容，如果是，产生冲突；如果不是修改同一个文件，直接合并，不产生冲突


## 文件恢复 & 版本恢复 ##
> 在你已经提交过之后，在工作区不小心误删了一些文件，如何恢复工作区被删掉的文件，或者让工作区回到某个版本库下的所有文件

- git reflog：查看提交后的版本哈希值
- git checkout 哈希值 文件名：恢复工作区被删掉的指定文件
- git reset --hard 哈希值：恢复工作区到指定版本


## 撤销大集合 ##
- git checkout -- 文件名：撤销还没有添加到暂存区的文件的修改(工作区写的代码会被撤销掉)
- git commit -m '描述文字' --amend：替换掉上一次的commit描述
- git reset "HEAD^"：撤销提交（一个 ^ 表示撤销一次提交，可以多个连续撤销比如："HEAD^^"）
- git reflog：打印提交记录（会显示提交的哈希值）
- git reset 哈希值：撤销到指定哈希的那次提交(比如提交日志为：commit 4f62c9b283b5e...；那么 4f62c9b 就是哈希值)


## git存储及操作 ##
> 当在一个分支上修改内容，并且已经添加到暂存区了，但是没有做commit提交，然后切换到另一个分支上进行了另外的操作，当在另一个分支上添加commit的时候，你会发现提交的时候会带上之前分支暂存区中的内容，这个时候你提交的话，会把两个分支在暂存区中的所有改动都提交上

- git stash：存储当前分支在暂存区的内容
- git stash list：查看当前分支存储的内容
- git stash apply 存储编号：获取当分支存储的内容
- git stash drop：删除当前分支存储
- 推荐在当前分支上操作完了后，在切换到另外的分支前，先用commit去提交当前分支

经过stash操作后，在切换到别的分支进行操作和提交的时候，就不会带有之前分支暂存区的内容了


## 配置忽略文件 ##
> 用git指令 touch.gitignore 创建配置信息文件，列出不需要被git追踪的文件信息，也就不会上传到中央仓库中

- #：该行都会被忽略
- *：匹配零个或多个任意字符
- [abc]：匹配任意一个方括号内的字符
- ?：只匹配一个任意字符
- **：匹配任意中间目录
- !：忽略指定文件以外的文件或目录
- [0-9]：在这个范围的都可以匹配


## tag标签 ##
> 我们经常会看到下载软件分为 "xx版本"，这个 "xx版本" 其实就是版本标签，该标签指向一个commit对象，虽然我们也可以用这个commit对象进行版本的表述，但是由于哈希太长，并且没有规律，所以我们使用标签的方式进行版本管理

本地打tag标签

- git tag 版本号：设置tag
- git tag：查看版本号
- git tag -d 版本号：删除标签
- git tag 版本号 哈希值：给指定 commit 提交设置标签
- git tag -a 版本号 -m "标签描述"：设置tag描述 （使用 "git show 版本号" 可以查看tag描述信息）

线上打tag标签：线上打tag之前记得用本地分支去merge下线上master分支

1. 打开git命令行
2. 切换到你要打tag的分支上去，并输入如下示例语句：git tag -a tag标签 -m "描述信息"（比如：git tag -a tag_1.0.0 -m '测试打tag'）
3. 输入命令行：git push origin tag_1.0.0 ，此处的“tag_1.0.0”与上面语句中的“tag_1.0.0”要一致，否则是无效的
4. 打开gitlab查看tags信息
