【@】XML与HTML的区别：
1、语法有所不同：XML语法比较严谨而HTML语法比较松散。
2、用途不同：XML主要用于数据的储存和传输，而HTML主要用于网页的编辑。
总结：HTML语言旨在显示信息，XML旨在传输信息。


【@】XHTML与HTML的区别：可以理解为XHTML是HTML的严格模式，是对HTML标签和属性的书写更加规范的一种模式。(详解：书籍中的14、15页)
1、元素名必须是小写字母
2、元素属性用"包围,不能为空值
3、特殊字符需要转译后才能使用
4、空元素以 />结尾
5、.....

【@】XML HTML XHTML
XML：	文本标记语言
HTML：	超文本标记语言
XHTML： 更加严格的超文本标记语言


【@】javascript由三部分组成：
1、ECMAscript定义这门语言的标准：语句、语法、数据类型、运算符、关键字、保留字
2、DOM：文档对象模型，也就是html页面中的所有元素
3、BOM：浏览器对象模型，也就是提供了与浏览器交互的方法和接口


【@】外部javascript文件的.js扩展名并不是必须的，这样一来，使用JSP、PHP等其他服务器端的语言动态生成javascript代码也就可以实现了。

【@】函数用typeof 判断是返回 function 的，不是返回Object,因为ECMAscript觉得，对函数这个对象和其他对象做一个区分是用必要的。

【@】typeof：用typeof判断时，不管变量有没有被声明或被初始化，它的初始值都是undefined
var age; 
1、alert(age)			返回undefined
2、alert(message)		直接报错
3、alert( typeof message )	返回undefined

【@】数值转换的三种方法：Number()、parseInt()、parseFloat()
1---Number()		可以转换任何类型的数据
2---parseInt()		专门用于转换字符串类型
	它能转换二、八、十、十六进制的数字字符，并且在ECMAscript不同版本中，解析也有一定的差别，所以，建议都使用十进制的方法，传人第二个参数10
	var num=parseInt('100',10);
3---parseFloat()	专门用于转换字符串类型
	它只解析十进制的值，所以不用传人第二个参数

【@】转换成字符串的三种方法：toString()、String()、用单引号或双引号连接
1---变量.toString() 方法可以接收有限的进制参数，模式是十进制的参数10，并且可以转换成对应的进制值；null和undefined没有这个方法。
	null.toString()		---报错
	undefined.toString()	---报错
2---String()   方法可以转换任何类型的数据，包括null和undedfined。
	String(null)		---'null'
	String(undefined)	---'undefinded'

3---用单引号或双引号连接
var num1=10;
var num2=''+num1+'';
console.log( num2 );

【@】一元操作符：++ --
1：++num -> num=num+1; 操作符前置的结果是马上做出运算的。
2：--num -> num=num-1; 操作符前置的结果是马上做出运算的。
3：num++ -> num=num+1; 操作符后置的结果不会马上做出运算，它是等下一次出现num这个值时，在去做+1的处理。
4：num-- -> num=num1;  操作符后置的结果不会马上做出运算，它是等下一次出现num这个值时，在去做-1的处理。

(注意：一元操作符不仅可以计算数字类型的值，其他类型的值都可以计算，在运算其他类型的值的时候，会调用Number()方法进行转换后再执行，转换不了就是NaN )

实例1：前置
var num1=10;
var num2= ++num1 + 2;
console.log( num1,num2 );	得到 num1=11; num2=13;

实例2：后置
var num1=10;
var num2= num1++ + 2;
console.log( num1,num2 );	得到 num1=11; num2=12;

【@】null和undefined做比较
alert(null==undefined)		返回true
alert(null===undefined)		返回false

【@】while语句：前测试语句，里面的代码有可能执行，也可能不执行
while(i<10){
	i+=1;
}
(当i<10为真时，里面的代码一直会循环执行，直到它为假)

【@】do-while语句：后测试语句，里面的代码至少会被执行一次
do{
	i+=1;
}while(i<10)；
(当i<10为真时，里面的代码一直会循环执行，直到它为假)

【@】通过BOM向页面中写入东西：document.write('......')

1---直接写在<script></script>里的话，它是直接在页面去插入写入的东西  <script> document.write('添加的内容') </script>

2---直接写在<script></script>里的window.onload...里的话，它会去替换body里面所有的东西，把它变为写入的东西

【@】事件委托的原理：就是利用事件冒泡的机制，把事件添加在父级上面，然后通过寻找事件源去找到父级里面本来要添加的元素，对他进行操作

【@】for-in 循环：
if(obj!=null && obj!=undefined){
    for(var attr in obj){
        console.log(1)
    }
}else{
    console.log( 'obj is null || undefined' )
};
(注意，如果循环的对象是null或者undefined的话，在低版本某些浏览器里面可能会报错，所以在使用for-in循环的时候，最好先判断是否为这个两个值)

【@】for循环和while循环：
for循环：  for(var i=0; i<10; i++){ alert(i) }
while循环：while(i<10){ alert(1); i++ }
(意思为，i的初始值为0，当i<10成立的时候就马上执行for里面的代码，执行完成之后，在对i++；)

【@】如何删除引用类型里面的某个值：var obj={ name:'小明', age:20 }
1---给这个obj重新用=号赋值		var obj={ name:'小明' }
2---用delet方法去删除指定的某个属性	delete obj.age;

【@】基本类型关于复制的原理：基本类型的复制会重新创建一个新的内存空间，他们互不影响。
var num1=5;
var num2=num1;
++num1;
console.log(num1,num2)		//得到：6  5

【@】引用类型的复制的原理：引用类型的复制不仅会把值给它，而且还会把内存中的地址也给它，变量其实就是一个指针，就相当于他们其实是一个东西，是会相互影响的。
var obj1={ name:'小明',age:20 };
var obj2=obj1;
delete obj2.age;
console.log(obj1,obj2)		//都得到：{ name:'小明' };

【@】函数中传递参数时的区别：
1---参数为基本类型：和基本类型的复制是一样的原理
var num=10;
var sum=fn(num);

function fn(n){
	++n;
	return n;
};

console.log(num)	// 10
console.log(sum)	// 11

2---参数为应用类型：和应用类型的复制是一样的原理
var obj1={ name:'小明',age:20 };
var obj2=fn(obj1);

function fn(obj){
	obj.name='小红';
	return obj;
};

console.log(obj1);	// { name:'小红',age:20 };
console.log(obj2);	// { name:'小红',age:20 };

【@】'='号的赋值对应用类型的影响：不管=号右边是什么类型的值，相对于obj而言都是开辟了新的内存空间，与原来的赋值对象没有任何关联
1---赋值对象
var obj1={ name:'小明',age:20 };
var obj2=obj1;
obj2={ name:'小红',age:30 };

console.log(obj1)	// { name:'小明',age:20 };
console.log(obj2)	// { name:'小红',age:20 };

2---赋值基本类型
var obj1={ name:'小明',age:20 };
var obj2=obj1;
obj2='字符串';		// obj2端开了与初始对象的指针

console.log(obj1)	// { name:'小明',age:20 };
console.log(obj2)	// '字符串';

【@】数据类型的最佳判断方法：
1---typeof：主要用来判断基本类型(null除外)，判断null的时候返回的是Object,判断函数的时候返回的是function,判断未声明的变量的时候返回的是undefined
var str='字符串';
alert( typeof str )	// String

2---instanceof：主要用来判断引用类型,它是通过原型链来判断的(有缺陷)
var arr=[];
alert( arr instanceof Array )	// true
alert( arr instanceof Object )	// true

var arr=new RegExp;
alert( arr instanceof RegExp )	// true
alert( arr instanceof Object )	// true

3---Object.prototype.toString.call('数据')：主要用来判断引用类型，它是通过构造函数来判断的(最精准)
var arr=[];
alert( Object.prototype.toString.call(arr)=='[object Array]' ) 	//返回true
alert( Object.prototype.toString.call(arr)=='[object Object]' ) //返回false

【@】执行环境：全局、局部
1---环境中定义的所有变量都保存在一个对象中，前端无法直接访问这个对象，但解析器在后台处理数据时会解析它。
2---在Web浏览器中，全局执行环境是window，所有定义的全局属性和方法都挂载在window对象下面。
3---局部执行环境里面的所有代码都被执行完毕后，该环境被销毁，该环境里面的所有变量和函数定义也会被销毁(排除闭包的影响)。
4---全局执行环境只有在关闭网页或浏览器的时候才会被销毁。

【@】条件判断语句中声明的任何变量都是相当于声明在条件判断语句的外边：
1---例子：if with while for 等
if(true){
	var num=10;
}
alert(num)	//弹出 10

【@】特殊的条件判断语句：with(){}  它也是执行环境中“延长作用域链”的一种常见方式(不推荐使用，因为会比其他的条件判断语句更耗内存)
with(location){
	alert(href)
	alert(search)
	alert(hash)
}
(提示1：在with语句中，变量location对象会被作为该环境中最外层的执行对象添加到with语句中，所以直接可以用简写的方式访问location里面的变量和方法)
(提示2：所以在with语句中访问href等值的时候，就相当于访问location.href)
(提示3：try{}catch(e){} 语句也可以延长作用域链)

【@】垃圾收集机制：
1---javascript具有自动的垃圾收集机制，也就是说，执行环境会负责管理代码在执行过程中所占用的内存。它会找出执行环境中不在继续使用的变量，然后释放占用的内存。
2---局部执行环境会在执行完后自动销毁以释放占用的内存，而全局执行环境者可以通过垃圾收集机制，定时的收集一次，然后释放内存。
3---垃圾收集机制的目的是防止运行javascript时耗尽所有的内存空间而系统崩溃。
(提示：如果你在全局环境中声明一个变量，而这个变量在整个执行环境中都没有被用到过，那么垃圾收集机制就会释放那个变量所占用的内存)

[释放内存的方法之一]
function crentePerson(name){
	.....
}
var person=crentePerson('参数')
....
person=null;	// 对于内存占用比较大的代码块而言，为了不让它在执行完毕之后依然占用过多的内存，可以手动释放它占用的内存

/*--------------------------------------------------------------引用类型&对象------------------------------------------------------------------*/

【@】引用类型&对象：
1---引用类型：它是一种数据结构，描述的是一类对象所拥有的属性和方法
2---对象：它是某个特定引用类型的实例
3---对象是一个引用类型

【@】数组：
var arr=[1,2];
arr[99]=99;
console.log(arr)		// [1,2,99:99]
console.log(arr.length)		// 100
(提示：第3-98位都是不存在的，而且不会反应在数组中，但访问他们的值的时候，会返回undefined值)

【@】检测是不是数组：
var arr=[];
1---只有一个全局作用域的情况下
	arr instanceof Array  或者  Object.prototype.toString.call(arr)==['Object Array'] 
2---有多个全局作用域的情况下
	Array.isArray(arr)

【@】数组的toString和valueOf方法：
1---toString:返回以逗号分隔的字符串，不会改变原来数组
2---valueOf: 返回原来数组，不会改变原来数组
3---null和undefined
var arr=[null,undefined];
console.log(arr.toString())	// ,
console.log(arr.valueOf())	// [null,undefined]


【@】数组的indexOf查询方法：代表查找位置，返回查找项的下标，没有找到返回-1
1---1个参数，代表从0下标位置开始查找
var arr=[1,2,3,4]
alert( arr.indexOf(2) )		//返回 1

2---2个参数，查找那个值，从那个下标开始查找
var arr=[1,2,3,4]	
alert( arr.indexOf(3,1) )	//返回 2

【@】数组常用方法0：slice(参数)，使用该方法后不会改变原来数组
1---一个参数：
var arr=[1,2,3,4,5];
var arrT=arr.slice(2)
console.log(arr)	// [1,2,3,4,5]
console.log(arrT)	// [3,4,5]

1---两个参数：
var arr=[1,2,3,4,5];
var arrT=arr.slice(2,4)
console.log(arr)	// [1,2,3,4,5]
console.log(arrT)	// [3,4]


【@】数组常用方法1：splice(参数)，使用该方法后会改变原来数组
1---删除方法：
var arr=[1,2,3,4,5,6,7];
arr.splice(2,2);	// 从下标为2的地方开始往后删除2项
alert(arr)		// [1, 2, 5, 6, 7]

2---插入方法：
var arr=[1,2,3,4,5,6,7];
arr.splice(2,0,8,9);	// 在下标为2的地方往前面插入8和9
alert(arr)		// [1,2, 8, 9, 3, 4, 5, 6, 7]

3---替换方法：
var arr=[1,2,3,4,5,6,7];
arr.splice(2,1,8);	// 删除下标为2的值，替换成8
alert(arr)		// [1, 2, 8, 4, 5, 6, 7]

【@】数组常用方法2：every(函数)
var arr=[1,2,3,4,5,6,7];
var sum=arr.every(function(item){
		return item>3;		//查看数组中的每一项，如果都大于3就返回true，只要有一项小于3就返回false
});
alert(sum)	// 返回false

【@】数组常用方法3：some(函数)
var arr=[1,2,3,4,5,6,7];
var sum=arr.some(function(item){
		return item>3;		//查看数组中的每一项，只要有一项大于3就返回true，否则返回false
});
alert(sum)	// 返回true

【@】数组常用方法4：filter(函数)
var arr=[1,2,3,4,5,6,7];
var sum=arr.filter(function(item){
	return item>3;			//查看数组中的每一项，去掉不大于3的值
});
alert(sum)	// 返回[4,5,6,7]

【@】数组常用方法5：map(函数)
var arr=[1,2,3,4,5,6,7];
var sum=arr.map(function(item){
	return item*2;			//查看数组中的每一项，并且每一项都×以2
});
alert(sum)	// 返回[2, 4, 6, 8, 10, 12, 14]

【@】数组常用方法6：forEach( function(element, index){执行某些操作} )
var arr=['小红','小强','小明','小芳'];
arr.forEach(function(element, index){
	if(element=='小明'){
		alert('小明这个人在数组中的下标值为：'+index)	//小明这个人在数组中的下标值为：2
	};
});

【@】数组求和方法：
1---for循环：
var sum=0;
for(var i=0; i<arr.length; i++){
	sum+=parseFloat(arr[i]);
};
console.log(sum)

2---forEach循环：
var sum=0;
arr.forEach(function(item,index,array){
	sum+=parseFloat(item);
});
console.log(sum)

3---reduce方法：IE8不支持该方法
var arr=[1,2,3,4,5];
var sum=arr.reduce(function(prev,cur,index,array){
	return prev+cur;
});
console.log(sum)

【@】分析函数声明和函数表达式的区别：联想作用域那块

1---函数声明：在浏览器执行代码之前会先找到函数这个对象，如果发现有同名的函数声明，它会保留最后解析的那个函数对象，把其他同名的函数对象都销毁掉，所以对于同名的函数声明对象而言，解析器永远只会保留最后的函数对象。
sum(10,10);			// 20
function sum(num1,num2){
	return num1-num2;
}
function sum(num1,num2){
	return num1+num2;
}

2---函数表达式：
//sum(10,10)；			// 报错，在浏览器解析的时候没有sum这个函数声明
var sum=function(num1,num2){	// sum指针指向函数对象 function(num1,num2){return num1-num2;}
	return num1-num2;
}
console.log(sum(10,10))		// 0
var sum=function(num1,num2){	// sum修改函数指针，指针指向函数对象 function(num1,num2){return num1+num2;}
	return num1+num2;
}
console.log(sum(10,10))		// 20

【@】函数指针问题：函数名只是指向内存中函数对象的一个指针而已
function sum1(num1,num2){	// 这一步表示：它是个函数声明，在下面的代码中也没有找到同名的函数声明，所以sum1的指针指向函数 function(num1,num2){return num1+num2;}
	return num1+num2;
};
var sum2=sum1;			// 这一步表示：sum2这个变量的指针也指向函数对象1:function(num1,num2){return num1+num2;}
alert( sum2(10,10) );		// 20
sum1=function(num1,num2){	// 这一步表示：sum1的指针指向了一个新开辟的内存函数对象2，这样就与function(num1,num2){return num1+num2;}这个函数对象无关了
	return num1-num2;	// 也就是说内存中存在了两个函数对象，sum1指针指向function(num1,num2){return num1-num2;}；sum2指针指向function(num1,num2){return num1+num2;}
};			
alert( sum1(10,10) );		// 0
alert( sum2(10,10) );		// 20	

【@】分析函数指针问题：函数表达式
var sum1=function(num1,num2){	// 在内存中开辟了一个函数对象1 function(num1,num2){return num1+num2;}，sum1的指针指向它
	return num1+num2;
};
var sum1=function(num1,num2){	// 在内存中右开辟了一个函数对象2 function(num1,num2){return num1-num2;}，sum1修改了它的指针
	return num1-num2;
};
alert( sum1(10,10) );		// 0
(提示：当一个函数对象被保存在内存中的时候它就已经存在了，你只要关心是哪一个变量指针指向它就可以了)


【@】函数内部属性：arguments、this
1---arguments:它是一个类数组，包含传人函数内部的所有参数，它还有一个属性callee，这个属性是一个指针，这个指针指向拥有这个arguments的函数对象。
function Fn(num1){
	console.log(arguments.callee);		// function Fn(num1){console.log(arguments.callee);}
};

【arguments.callee在实际中的作用】：避免因为函数名紧密耦合而出现的异常情况
1---做5*4*3*2*1的运算
var sum=foctorial(5);		
console.log(sum)
function foctorial(num){
	if(num<=1){
		return 1;
	}else{
		return num*foctorial(num-1);	//这个递归算法与函数名紧密相连，这样可能会出问题，所以可以改写成这样：return num*arguments.callee(num-1);请看下面实例
	}
};

2---运用arguments.callee去消除因为函数名紧密耦合而出现的异常情况
var sum=foctorial;			// sum指针指向最下面的函数对象
foctorial=function(num){return 0};	// 变量foctorial重新开辟新对象，销毁之前的指针
console.log( sum(5) )			// 120
console.log( foctorial(5) )		// 0

function foctorial(num){
	if(num<=1){
		return 1;
	}else{
		return num*arguments.callee(num-1);	// 即使变量foctorial的指针被重新定义，但函数对象体在内存中不会受影响
	}
};


【@】函数对象有两个属性：length、prototype
1---length: 表示函数希望接收命名参数的个数
function sum(name,age){
	return 1;
}
alert(sum.length)	// 2

2---prototype: 函数的prototype下面有很多其他的属性和方法，但这些属性和方法不能用for-in循环去枚举，比如call、apply等

【@】基本类型的包装对象
1---字符串：基本的数据类型理论上是没有属性和方法的，但它有属性和方法可以用。
var str1='hello javascript';
var str2=str1.substring(2);
(提示：当读取基本类型时，后台就会创建一个和它对应的包装对象，然后这个基本类型就可以调用它里面的属性和方法，如下面代码所示)

var str1=new String('hello javascript');	// 创建String类型的一个实例
var str2=str1.substring(2);			// 在实例上调用prototype对象下面的substring方法
str1=null;					// 销毁这个实例

【@】引用类型对象和基本类型的包装对象的区别：生命周期不同
1---引用类型对象：在执行流离开当前作用域之前，这个引用类型对象都一直保存在内存中，所以可以任意的给引用类型对象添加属性和方法
2---基本类型的包装对象：它是在执行流执行到这一行代码的时候，自动在后台创建的，当创建的包装对象的属性或方法被调用完成之后，它就会被马上销毁，所以不能在基本类型上面任意的添加属性和方法。

var str1='hello javascript';
str1.color='red';	// 因为包装对象被销毁了，所以无法在基本类型上面去添加属性或方法
alert(str1.color);	// 它会创建一个包装对象实例，但是并没有在它的prototype原型链上找到color这个属性，所以得到undefined

【@】永远不要使用 new Boolean()这个包装对象，因为在使用typeof和instanceof判断类型的时候很容易混淆错误   (书籍：120页)
【@】永远不要使用 new Number()这个包装对象， 因为在使用typeof和instanceof判断类型的时候很容易混淆错误   (书籍：122页)

【@】Number类型下面的方法：toFixed() 按照指定的小数位返回数值的字符串类型
var num=12.567;
alert( num.toFixed(2) )		// '12.57'


【@】Global对象：它可以说是ECMAscript中最特别的一个对象，因为它不属于任何其他对象的属性和方法，最终都是它的属性和方法 (书籍133页)
1---方法：isNaN、parseInt、parseFloat等
2---属性：所有原生应用类型的构造函数  Number、String、Object、Function、Array等
3---前端人员无法直接访问这个对象,不然会报错
4---虽然我们无法直接访问Global对象，但可以用window对象去访问Global对象下面的属性和方法，window和Global是全等的
var num=10；
alert( isNaN(num) )	// 实际上是在后台调用了Global对象的isNaN方法，但我没不能直接访问这个对象 比如改写成：Global.isNaN(num)

【@】代码注入 ：Global对象下面的eval方法		eval('字符串参数')；
1---能够解析‘代码字符串’的程序方法都是非常强大，同时也非常危险的。
2---代码注入：通过能够解析 ‘代码字符串’能力的程序去往页面中添加他人的程序语言，这样可能会恶意植入威胁你站点或应用程序的代码。
3---所以在要执行用户输入数据的地方要特别提防像eval这种代码注入造成的威胁。

//实例1：
var str='hello word';		// 你可以把这个变量赋值函数试试
eval( 'alert(str)' );		// 这个地方会被解析器解析为：alert(str) 然后在执行的时候放回原来位置去执行

//实例2：
var str='hello word';
eval("setTimeout(function(){\
	str='Fuck you';\
}, 1000);");
document.onclick=function(){
	alert( str );		// str被其他人恶意改变为 Fuck you
};

【@】在所有代码执行之前，作用域中就已经存在了两个内置对象:Global、Math，大多数ECMAscript都不能直接访问Global对象，但Web浏览器实现了承担该角色的window对象来访问Global对象
下面的属性和方法。

【@】ECMAscript中的两种属性：数据属性and访问器属性  (书籍139页--141页)
1---数据属性：不要使用这些属性
	[[Configurable]]:表示能否通过delete去删除对象的属性，从而重新定义属性，默认值为true
	[[Enumerable]]  :表示能否通过for-in循环返回属性，默认值为true
	[[Writable]]	:表示能否修改属性值，默认值为true
	[[Value]]	:表示某个属性的值

//实例1：修改name值
var obj={ name:'小明' };
obj.name='小红';
console.log(obj.name)	// 小红

//实例2：让其他人无法修改name值  Object.defineProperty(对象, 属性名称, 描述符)
var obj={};
Object.defineProperty(obj, 'name', {
	Writable:false,
	value:'小明'
});
obj.name='小红';
console.log(obj.name)	// 小明

2---访问器属性：
	[[get]]:在读取属性时调用的函数，默认值为undefined
	[[set]]:在设置属性时调用的函数，默认值为undefined

//实例：修改book的某个属性值，去发生关联事件
var book={
	_year:2004,	// 下划线是一种常用的标记，用于只能通过对象方法访问的属性
	edition:1
}
Object.defineProperty(book, 'year', {
	get:function(){
		return this._year;
	},
	set:function(newValue){
		if(newValue>2004){
			this._year=newValue;
			this.edition=2;
		};
	}
});
book.year=2005;
console.log(book);	// {_year: 2004, edition: 2}

/*-------------------------------------------------------继承------------------------------------------------------*/

【@】原型的继承方法：封装方法简单继承方法
function extend(obj1,obj2){
	for( var attr in obj2 ){
		obj1[attr]=obj2[attr]
	}
}

[实例]:
function Person1(){}
Person1.prototype.age=24;
Person1.prototype.sex='男';
function Person2(){}
var per1=new Person1();
var per2=new Person2();

extend(Person2.prototype,Person1.prototype)
console.log(Person2.prototype)			// {age: 24, sex: "男"}


【@】经典继承1：通过原型链继承实例对象和原型对象上的的属性和方法
function Person1(){this.sex='男'};
Person1.prototype.name='小明';
Person1.prototype.age=20;

function Person2(){};
Person2.prototype=new Person1();	// 让它的原型=另一个对象的实例
Person2.prototype.constructor=Person2;	// 改变constructor指向，不然它会指向Person1构造函数

var per2=new Person2();
console.log(per2.sex)			// 男
console.log(per2.name)		// 小明
console.log(per2.age)		// 20


【@】经典继承2：通过对象实例继承实例对象的属性和方法
function Person1(){  this.arr=[1,2,3,4,5] };
function Person2(){
	Person1.call(this)	// 单独继承Person1里面的所有属性和方法(注意不是继承Person1.prototype下面的属性和方法)
};

var per2=new Person2();
var per3=new Person2();
per2.arr.push(6);					

console.log(per2.arr)		// [1,2,3,4,5,6] 
console.log(per3.arr)		// [1,2,3,4,5] 


【@】经典继承3：组合1和2
function Person1(){this.name='小明'};
Person1.prototype.age=20;

function Person2(){
	Person1.call(this);		// 继承私有属性
};
Person2.prototype=new Person1();	// 继承公有属性
Person2.prototype.constructor=Person2;

var per2=new Person2();


【@】对象的枚举方法：
1---for-in循环：他可以循环对象实例本身和原型上面所有的属性
function Person(name){}
Person.prototype.age=20;

var person1=new Person();
person1.name='小明';
for(var attr in person1){
	console.log(attr)	// name、age
};

2---Object.keys(对象)：它只循环参数对象本身
function Person(name){}
Person.prototype.age=20;

var person1=new Person();
person1.name='小明';
console.log( Object.keys(person1) )	// name

/*-------------------------------------------------------end继承------------------------------------------------------*/


/*---------------------------------------------创建对象：js设计模式(第六章)----------------------------------------------------*/
【工厂模式】：其实就是函数封装，解决多个相似对象的问题
     优点：代码的重复利用
     缺点：无法分辨对象类型，因为你用constructor或者instanceof去做类型判断的时候，容易混淆

【实例】：
function creatPerson(name,age,sex){
	var obj=new Object();
	obj.name=name;
	obj.age=age;
	obj.sex=sex;

	return obj;
};
var creat1=creatPerson('小明',20,'男');
var creat2=creatPerson('小红',18,'女');
console.log(creat1.name)			// 小明
console.log(creat2.name)			// 小红
alert( creat1.constructor==creatPerson )	// false：
alert( creat1.constructor==Object )		// true，这个地方就有问题了，因为其他很多对象的构造函数默认都是Object
(提示：constructor：每创建一个函数，后台会在这个函数身上创建prototype对象，而prototype对象上面就会自动生成constructor属性，该属性指向构造函数，而普通的函数声明的构造函数为：function Object(){...})

【构造函数模式】：通过new创建出来的对象形式
	优点：代码的重复利用，并且可以和普通的函数进行区分，同时在将来也可以为同一个构造函数的新对象都打上不同的标识
	缺点：每次通过new创建出来的对象，在构造函数里面如果有其他函数赋值，比如this.fn=function(){}，因为this指向不一样，所以，函数赋值时，都会在内存中开辟新的作用域

【实例】：
function CreatPerson(name,age,sex){
	this.name=name;
	this.age=age;
	this.sex=sex;
	console.log(this)	// this指向创建出来的新对象本身，即creat1或creat2；构造函数里面返回的默认值也是creat1或creat2；
	this.Fn=function(){xxx};
};
var creat1=new CreatPerson('小明',20,'男');
var creat2=new CreatPerson('小红',18,'女');
console.log(creat1.name)			// 小明
console.log(creat2.name)			// 小红
alert( creat1.constructor==CreatPerson )	// true
alert( creat1.constructor==Object )		// false
alert( creat1.Fn==creat2.Fn )			// false	// 这也就是问题所在，每次调用函数都是开辟新的作用域


【原型模式】：构造函数的prototype下面去挂载属性和方法(每创建一个函数，后台会在这个函数身上创建prototype对象,prototype其实是一个指针，指向内存中的一个对象)
	优点：代码的重复利用，并且在构造函数的prototype原型上去挂载属性和方法的好处就是，让同一个构造函数都能共享prototype包含的所有属性和方法
	缺点：共享本性在有时候也会带来弊端(看下面实例2)

【实例1】：
function CreatPerson(name,age,sex){
	this.name=name;
	this.age=age;
	this.sex=sex;
};
CreatPerson.prototype.Fn=function(){	// CreatPerson.prototype就是创建出来的新对象creat1或creat2，
	console.log('原型函数');
};
var creat1=new CreatPerson('小明',20,'男');
var creat2=new CreatPerson('小红',18,'女');

alert( creat1.Fn===creat2.Fn )		// true

【实例2】：原型模式的共享本性，也是它的最大弊端
function Person(){};
Person.prototype.arr=[1,2,3,4,5];

var person1=new Person();
var person2=new Person();
person1.arr.push(6);		// Person.prototype.arr被修改了，会反应到所有通过new 构造函数创建出来的新对象上面

console.log(person1.arr)	// [1, 2, 3, 4, 5, 6]
console.log(person2.arr)	// [1, 2, 3, 4, 5, 6]


【构造函数模式+原型模式】：构造函数模式用来定义私有属性和方法，原型模式用来定义共享属性和方法
function Preson(name,age){
	this.name=name;
	this.age=age;
	this.arr=[1,2,3,4,5];
};	
Preson.prototype.fn=function(){
	alert(1);
};
var pre1=new Preson('小明',20);
var pre2=new Preson('小红',18);
console.log( pre1.name )	// 小明
console.log( pre2.name )	// 小红

【动态原型模式】：其实就是用if去判断实例对象下面有没有这个属性或方法，如果没有，就在原型prototype下面去添加这个属性或方法，然后其他实例对象都会在prototype下面找到这个属性或方法
function Preson(name,age){
	this.name=name;
	this.age=age;
};	
if(typeof this.sum != "function"){
	Preson.prototype.sum=function(){
		alert(this.name)
	};
};
var pre1=new Preson('小明',20);
pre1.sum();			// 小明
var pre2=new Preson('小红',18);
pre2.sum();			// 小红		


【寄生构造函数模式】：这个模式可以在特殊情况下用来对对象创建构造函数，比如我们下创建一个具有额外功能的特殊数组，但不我们有不能直接对原生的Array数组构造函数做处理，所以就有了下面的方法
function SpeliArray(){
	//创建数组
	var values=new Array();
	//添加值
	values.push.apply(values,arguments);
	//添加方法
	values.arrayJoin=function(){
		return this.join('|');
	};
	//返回创建的数组
	return values;
};
var arr=new SpeliArray('red','blue','green');
var arrJ=arr.arrayJoin();
console.log(arrJ)			// 'red|blue|green'

【稳妥构造函数模式】：所谓的稳妥对象，指的是没有公共属性或方法，而且在构造函数内部不使用this对象，它适用于一些特殊的环境(禁止使用this和new关键字创建对象的地方)
function Person(name,age){
	var o=new Object();
	o.sum=function(){
		alert(name)
	};
	return o;
};

var person=Person('小明',20);
person.sum();

【模块模式】：定义一个对象，并且提供一些公有的数据，同时还要提供能够访问这些公有数据的方法，最后返回唯一接口
var YQH=function(){
	// 公有变量
	var num1=10;
	var num2=20;
	// 提供对外接口，使用对象并绑定匿名函数
	return {
		getNum1:function(){
			alert(num1)
		},
		getNum2:function(){
			alert(num2)
		}
	};
}();
// 访问唯一的对外接口
window.onload=function(){
	YQH.getNum1();
};


/*---------------------------------------------------end：js设计模式---------------------------------------------------------*/

【@】查看对象实例上的属性是实例本身的还是实例构造函数原型上的
1---hasOwnProperty()：对象实例上有特定属性就返回true，没有就返回false
function CreatPerson(){};
CreatPerson.prototype.name='names';
var creat=new CreatPerson();
alert(creat.hasOwnProperty('name'))	// false
creat.name='小明';
alert(creat.hasOwnProperty('name'))	// true

2---in		  ：对象实例或原型上有特定属性都返回true
function CreatPerson(){};
CreatPerson.prototype.name='names';
var creat=new CreatPerson();
alert('name' in creat)	// true
creat.name='小明';
alert('name' in creat)	// true

[封装判断对象实例本身上面是否有特定属性函数]：如果对象实例本身上有特定属性就返回false，如果在对象实例上没有而原型上有，就返回true
function hasPrototypeProperty(obj,name){
	return !obj.hasOwnProperty(name) && (name in obj);
};

【@】枚举对象实例的属性
1---枚举可枚举的所有属性(有些属性是规定不能枚举的，比如：constructor)
function Person(){};
Person.prototype.name='小明';
Person.prototype.age=20;

var keys=Object.keys(Person.prototype);
console.log(keys)		// ["name", "age"]
		
2---枚举所有属性,包含不可枚举的属性
function Person(){};
Person.prototype.name='小明';
Person.prototype.age=20;

var keys=Object.getOwnPropertyNames(Person.prototype)
console.log(keys)		// ["constructor", "name", "age"]



/*-------------------------------------------------函数表达式(第7章)-------------------------------------------------------*/
【条件判断语句里面不要出现函数声明】：
var oN=true;
sum();		// sum函数在这里解析会报错
if(oN){		// 永远也不要这样做，因为这在ECMAscript里面是属于无效语法的，XHTML里面也会报错
	function sum(){ alert(1)}
}else{
	function sum(){ alert(2)}
}

/*-------------------------------------------------------闭包----------------------------------------------------------*/

【闭包】：http://www.jb51.net/article/24101.htm
1---闭包就是能够读取其他函数内部变量的函数  (更准确的说法是：“有权访问”其他函数作用域中变量的能力)
2---JavaScript中所有的function都是一个闭包函数。不过一般来说，嵌套的function所产生的闭包更为强大，也是大部分时候我们所谓的“闭包”。
3---如果子级函数中有对父级函数作用域链中变量的引用的话，那么这个子级函数在执行完后不会得到释放,并且父级函数也因为子级函数中引用到了自己的变量，那么这个父级函数也不会被垃圾收集机制回收。
这样就形成了闭包函数，闭包函数也就会比其他普通的函数占用更多的内存，过度使用闭包会导致内存占用过多，甚至导致内存泄漏。

【闭包的作用】：
它的最大用处有两个，一个是可以读取函数内部的变量，另一个就是让这些变量的值始终保持在内存中。

[实例1]
function fn1(){
    var n=999;
    function fn2(){
        n+=1;
    }
    return fn2;
}
var fn3=fn1();
fn3();		// 这个fn3调用是形成闭包的主要原因，如果没有调用这个fn3那么fn1也就是一个简单的函数声明罢了

(提示：在fn3调用的时候，fn2函数里面用到了fn1中的变量n，那么这个fn2函数内存就不会被销毁,而fn2函数的存在依赖于fn1函数，因此fn1函数也始终在内存中，不会在调用结束后，被垃圾回收机制回收。)
(提示：fn1函数与fn2函数的这种关系就构成了一个强大的闭包函数)


[实例2]
function a() { 
    var i = 0; 
    function b() { 
     alert(++i); 
    } 
    return b;
}
var c = a();
c();		

(提示：这样在执行完var c=a()后，变量c实际上是指向了函数b，再执行c()后就会弹出一个窗口显示i的值(第一次为1)。这段代码其实就创建了一个闭包，为什么？因为函数a外的变量c引用了函数a内的函数b，
就是说：当函数a的内部函数b被函数a外的一个变量c引用的时候，就创建了一个闭包。)


[实例3]
function fn1(){
    var a=0;
    function fn2(){
        a+=1;
        alert(a);
    }
    return fn2;  
}
var obj1=fn1();
obj1();  	//结果为1	在内存中a的初始值为0，a+=1 之后 内存中a的值为1
obj1();  	//结果为2	在内存中a的值为1，所以在执行 a+=1的时候，内存中的a值变成2
var obj2=fn1();
obj2();  	//结果为1	在执行fn1函数时，因为又把内存中a的值变成了0，所以执行a+=1时，内存中的a变成1
obj2();  	//结果为2	在内存中a的值为1，所以在执行 a+=1的时候，内存中的a值变成2

(提示：obj调用的时候，fn2函数中用到了fn1函数中的变量a，所以在obj这个外部变量调用时，fn1和fn2函数中的变量a会保存在内存中而得不到释放，直到浏览器关闭为止)

[实例5]：垃圾回收机制
在Javascript中，如果一个对象不再被引用，那么这个对象就会被GC回收。
如果两个对象互相引用，而不再被第3者所引用，那么这两个互相引用的对象也会被回收。
如果两个对象互相引用，而被第3者所引用，那么这两个互相引用的对象就不会被回收。


[实例6]：思考闭包与垃圾回收机制的关联
function fn1() { 
    var i = 0; 
    function fn2() { 
        alert(++i); 
    } 
}
var fn3=fn1();

(提示：那么我们来想象另一种情况，如果fn1返回的不是函数fn2，情况就完全不同了。因为fn1执行完后，fn2没有被返回给fn1的外界，只是被fn1所引用，而此时fn1也只会被fn2引用，
因此函数fn1和fn2互相引用但又不被外界打扰(被外界引用)，函数fn1和fn2就会被垃圾回收机制回收，那么这个fn1闭包函数就不会造成闭包事件)

/*-------------------------------------------------------end闭包----------------------------------------------------------*/


/*-------------------------------------------------------内存泄漏----------------------------------------------------------*/

【前言】：
javascript具有自动垃圾收集机制，也就是说，执行环境会负责管理代码执行过程中的使用的内存。而在C和C++之类的语言中，开发人员的一项基本任务就是手动跟踪内存的使用情况，
这是造成许多问题的一个根源。在编写javascript程序时候，开发人员不用再关心内存使用的问题，所需内存的分配 以及无用的回收完全实现了自动管理。
而内存泄漏的一个基本点就是，由于代码书写过程中的问题，而导致一些变量无法被垃圾回收机制所回收，从而一直保存在内存中，直到页面关闭为止。

【什么是内存泄漏】：本该被垃圾回收机制所收回的变量或引用对象，因为某种原因而导致这些变量或引用对象无法被回收，从而一直保存在内存中而得不到释放。

【常见内存泄漏的原因】：

1---全局变量引起的内存泄漏：
function leaks(){  
    leak = 'xxxxxx';		// leak 成为一个全局变量，不会被回收
}

2---闭包引起的内存泄漏：
var leaks = (function(){  
    var leak = 'xxxxxx';	// 被闭包所引用，leak变量不会被回收
    return function(){
        console.log(leak);	// 这个子级函数引用了父级函数的变量，构成闭包函数的形成
    }
})()
leaks();			// 这个函数执行后就造成

3---dom元素引用在闭包函数中，并且伴随事件处理函数的触发：
function handler(){
    var element=document.getElementById('id');
    element.onclick=function(){
        alert(element.id)		// 这个匿名函数中的element就是闭包的作用域链中保存的那个HTML元素
    };
}
handler();
(提示：handler函数中包含html元素，而且在element.onclick的匿名函数体中引用了父级的element变量，所以就构成了闭包函数体，首先这个element元素不会被销毁掉，一旦这个元素被点击事件触发，
就会导致element元素被至少引用一次，这个元素和它的事件处理函数所占用的内存就永远不会被回收)

4---dom清空或删除时，事件未清除导致的内存泄漏：

$('#ID').bind('click', function(){
    console.log('click');
});

(下面是改写方法，防止内存泄漏)
$('#ID').bind('click', function(){
    console.log('执行代码');
    $(this).off('click');
});


/*----------------------------------------------------------end------------------------------------------------------------*/

【闭包与变量】：第一种形式
function creatFunction(){
	var result=[];
	for(var i=0; i<10; i++){
		result[i]=function(num){
			return i;
		};
	};					// for循环结束后i=10；而result里面保存了10个一样的函数 function(){return i}
	
	return result;				// 所以在返回result的时候，它变成 [function(){return 10},function(){return 10}...]
};
console.log(creatFunction()[0]())		// 10

【闭包与变量】：第二种形式
function creatFunction(){
	var result=[];
	for(var i=0; i<10; i++){
		result[i]=function(num){	// 这里的写法和 result[i]=i;是一样的，因为函数参数是按值传递的
			return function(){
				return num;
			};
		}(i);
	}
	return result;				// [0,1,2,3,4,5,6,7,8,9]
};
console.log(creatFunction()[0]())		// 0

【关于函数的this指向】：函数的默认this指向都是window，而当函数被作为某个对象的方法调用时，this指向那个对象
[实例1]：
var name='this window';
var obj={
	name:'this obj',
	getName:function(){
		return this.name;
	}
};
console.log( obj.getName() );		// obj.getName()改变了getName函数里面的this指向，所以得到'this obj'

[实例2]：
var name='this window';
var obj={
	name:'this obj',
	getName:function(){
		return function(){
			return this.name;
		}
	}
};
console.log( obj.getName()() );		// obj.getName()()其实是一个函数调用，但是它是直接被第一个匿名函数直接调用的，而并不是obj直接调用的，所以this指向没有改变，还是window

[实例3]：改写实例2
var name='this window';
var obj={
	name:'this obj',
	getName:function(){
		var that=this;
		return function(){
			return that.name;
		}
	}
};
console.log( obj.getName()() );		// 第二个匿名函数调用的是第一个匿名函数的this，而第一个匿名函数是被obj调用的，所以得到'this obj'


【内存泄漏】：
1---什么是内存泄漏：内存泄露是指一块被分配的内存既不能使用，又不能回收，直到浏览器进程结束。
具体来说就是，如果闭包的作用域链中保存着一个HTML元素，那么就意味着在闭包函数调用时，该元素将无法被销毁，因此它所占用的内存将永远不会被回收。

[实例1]：内存泄漏
function handler(){
    var element=document.getElementById('id');
    element.onclick=function(){
        alert(element.id)		// 这个匿名函数中的element就是闭包的作用域链中保存的那个HTML元素
    };
}
(提示：handler函数中包含html元素，而且在element.onclick的匿名函数体中引用了父级的element变量，所以就构成了闭包函数体，首先这个element元素不会被销毁掉，一旦这个元素被点击事件触发，
就会导致element元素被至少引用一次，这个元素和它的事件处理函数所占用的内存就永远不会被回收)

[实例2]：防止内存泄漏
function handler(){
    var element=document.getElementById('id');
    var id=element.id;			
    element.onclick=function(){
        alert(id)			// 这一步骤的作用是防止匿名函数直接引用element元素	
    };
    element=null;			// 确保垃圾回收机制能正常回收element占用的内存
}


2---常见的内存泄漏问题：
(1):给页面中的元素绑定事件处理函数或者该元素被移除、替换时，若元素绑定的事件处理函数仍没有被移除的话，那么在IE中就不会作出恰当处理，这样就存在内存泄露。
(2):在页面被关闭之前或刷新的时候，页面中的事件处理程序得不到很好的清理，那么这些事件处理函数就会滞留在内存中(IE8之前的版本或其他浏览器都有这样的问题)

解决方案1：闭包函数内部手动解除该元素的事件处理函数,比如：元素.onclick=null;
解决方案2：把元素身上的事件处理函数写在闭包外面；
解决方案3：利用事件委托机制


【匿名函数】：
1---因为在内存中没有指向匿名函数的引用，所以在匿名函数中定义的任何变量，在执行结束时都会被销毁
2---如果匿名函数里面返回的是它的闭包函数，那么声明的变量会保存在内存中
3---如果匿名函数里面返回的是另一个匿名函数，那么声明的变量会被回收



/*---------------------------------------------------end函数表达式---------------------------------------------------------*/


/*-----------------------------------------------------BOM(第八章)---------------------------------------------------------*/
【@】BOM的核心对象是window，它表示浏览器的一个实例。

【@】用var声明的全局变量无法通过delete删除，用window.变量 声明的全局变量可以用delete删除
var age=20;
window.color='red';

delete window.age;	    // 在小于IE9的浏览器中会报错
delete window.color;
console.log(age)            // 20
console.log(window.color)   // undefined

【@】setTimeout、setIntval定时器方法都有解析代码字符串的功能
setTimeout("(function(){alert(1)})()", 1000);
(提示：定时器的第一个参数最好为函数，如果是字符串的话会影响性能)

【系统对话框的三种形式】
1---alert(字符串参数)
2---confirm(字符串参数)

3---prompt(字符串参数，输入框显示的内容)	它会返回默认输入框内的内容
var prom=prompt('Aer you sure?', '请输您的建议');
if(prom){
	console.log('您选择了确定按钮:'+prom);
}else{
	console.log('您选择了取消按钮')
};

【@】封装'查询字符串参数'函数:getQueryStringArgs()	(书籍207页)
//假设查询字符串: ?names=javascript&num=10;
var args=getQueryStringArgs();
alert(args['names'])		// 'javascript'
alert(args['num'])		// '10'
(提示：该封装的方法可用来查询location的hash和search值里面传递的参数)

【@】浏览器历史管理禁止方法：replace(网址)
setTimeout(function(){
 	window.location.replace('http://www.baidu.com');
}, 1000);
(提示：1s后页面会跳转到百度页面，但历史管理的后退键却不能点击)

【@】浏览器重新加载：reload()
location.reload()	// 重新加载(有可能从缓存中加载)
location.reload(true)	// 从服务器端重新加载


【@】检测浏览器类型：navigator 	(书籍210页)

【@】检测浏览器中是否安装了某款插件	(书籍211-212页)

/*-------------------------------------------------------end BOM----------------------------------------------------------*/

/*---------------------------------------------------客户端检测(第九章)----------------------------------------------------*/

【客户端检测】：它是javascript开发中最受争议的一个话题，因为浏览器之前存在很多差异。
1---能力检测：不是直接判断浏览器类型，而是直接判断一个函数或者方法、属性是否能够执行，并且做出兼容处理，这是最常用的方法

2---怪癖检测：实际上是检测浏览器是否存在某些bug

3---用户代理检测：通过检测用户代理字符串来检测浏览器

/*-----------------------------------------------------end 客户端检测------------------------------------------------------*/

/*-----------------------------------------------------事件(第十三章)------------------------------------------------------*/

【@】事件流：页面元素接收事件的顺序：事件捕获、目标事件、事件冒泡
1---事件捕获：页面元素触发事件的时候，事件流应该是先从最外层开始，逐级往目标阶段触发 (IE9之前都不支持事件捕获)

2---目标事件：页面具体元素

3---事件冒泡：页面元素触发事件的时候，事件流应该先从目标元素开始逐级往外层触发 (所有浏览器都支持)
(IE提出的是事件冒泡机制，而其他浏览器提出的是事件捕获机制，到了IE9之后，IE也开始支持捕获机制了)

【@】给给定元素添加事件处理函数的三种方式：
1---直接添加：onclick等

2---通过方法添加：
	(1)IE9等其他浏览器: addEventListener('不加on的事件名'，事件处理函数(最好声明在外面)，false(是否有捕获阶段));
	(2)IE8之前浏览器: attachEvent('加on的事件名'，事件处理函数(最好声明在外面))
(提示：addEventListener最后的参数为不支持捕获的flase可以最大限度的兼容主流浏览器)

3---事件委托机制：event.target

【@】封装通过方法给元素添加事件的函数：书籍354页(兼容所有浏览器)
var EventUtil={
	addHandler:function(element,type,handler){
		if(element.addEventListener){
			element.addEventListener(type,handler,false);
		}else if(element.attachEvent){
			element.attachEvent('on'+type,handler)
		}else{
			element['on'+type]=handler;
		};
	},
	removeHandler:function(element,type,handler){
		if(element.removeEventListener){
			element.removeEventListener(type,handler,false);
		}else if(element.detachEvent){
			element.detachEvent('on'+type,handler)
		}else{
			element['on'+type]=null;
		};
	},

	// 下面新增加了四个方法;获取event对象、获取目标元素、阻止默认行为、阻止冒泡 (主要是为了兼容IE)
	getEvent:function(event){
		return event ? event ： window.event;
	},
	getTarget:function(event){
		return event.target || event.srcElement;
	},
	preventDefault:function(event){
		if(event.preventDefault){
			event.preventDefault();
		}else{
			event.returnValue=false;
		};
	},
	stopPropagation:function(event){
		if(event.stopPropagation){
			event.stopPropagation();
		}else{
			event.cancelBubble=true;
		};
	}
};


【@】鼠标坐标位置：client、page、screen
1---event.clientX / event.clientY: 	表示鼠标到可视窗口的最左边和最上边
2---event.pageX / event.pageY: 		表示鼠标到html视口的最左边和最上边( pageY=clientY+scrollTop )
3---event.screenX / event.screenY: 	表示鼠标到window窗口的最左边和最上边


【@】模拟事件：也叫做主动触发事件(书籍405-410页)
1---模拟鼠标事件：(IE8不支持)
var btn=document.getElementById('myBtn');
btn.onclick=function(){ alert('点击按钮触发') };	

// 创建事件对象
var event=document.createEvent('MouseEvents');
// 初始化事件对象
event.initMouseEvent('click',true,true,document.defaultView,0,0,0,0,0,false,false,false,false,0,null);
// 触发事件
btn.dispatchEvent(event);	// 在没有点击按钮的情况下，这个按钮的事件处理函数会被执行


2---模拟键盘事件：

3---模拟其他事件：


【@】自定义事件1：模拟鼠标事件也可以用来做自定义事件  (IE8不支持)
var btn=document.getElementById('myBtn');
// 绑定自定义事件	
EventUtil.addHandler(btn,'sss',function(event){
	alert('同名自定义事件1')
});
EventUtil.addHandler(btn,'sss',function(event){
	alert('同名自定义事件2')
});
var event=document.createEvent('MouseEvents');
event.initMouseEvent('sss',true,true,document.defaultView,0,0,0,0,0,false,false,false,false,0,null);
btn.dispatchEvent(event);


【@】自定义事件2：
//封装绑定自定义事件函数
function bindEvent(obj,events,fn){
	//为自定义事件做函数分类服务
	obj.listeners=obj.listeners||{};
	obj.listeners[events]=obj.listeners[events]||[];
	obj.listeners[events].push(fn); 
	//兼容判断
	if(obj.nodeType) return; //判断obj参数是否是元素
	if(obj.addEventListener){
		obj.addEventListener(events,fn,false);
	}else{
		obj.attachEvent('on'+events,function(){
			fn.call(obj);
		});
	};
};
//封装触发自定义事件函数
function fireEvent(obj,events){
	//执行所有在obj上通过bindEvent绑定的事件
	if(obj.listeners && obj.listeners[events]){
		for(var i=0; i<obj.listeners[events].length; i++){
			obj.listeners[events][i]();
		};
	};
};

[实例]：
var oBtn=document.getElementById('btn');
// 绑定自定义事件
bindEvent(oBtn,'show',function(){
	alert(1)
});
bindEvent(oBtn,'show',function(){
	alert(2)
});
// 触发自定义事件
fireEvent(oBtn,'show')


【@】：jq里面的自定义事件绑定和主动触发方法
元素.on('事件名'，fn);	--绑定自定义事件
元素.trigger('事件名')	--执行自定义事件

/*--------------------------------------------------------end 事件---------------------------------------------------------*/



/*-----------------------------------------------------表单脚本(书籍413)---------------------------------------------------*/

【@】获取表单元素的方法：
var form1=document.forms[0];			// 通过下标
var form1=document.forms['name值'];		// 通过name值
var form1=document.getElementById('ID值');	// 通过ID值

【@】表单提交：
1---<input type="submit" value="通用提交按钮">
2---<button type="submit">自定义提交按钮</button>
3---<input type="image" src="" value="图片提交按钮">
4---表单元素.submit();

【@】阻止表单提交：
1---阻止整个表单提交：event.preventDefault()
2---表单只读属性：<input type="text" readonly="readonly" value="数据">   表单value值不能被获得焦点，但能提交里面的数据
3---表单禁用属性：<input type="text" disabled="disabled" value="数据">   表单value值不E呢获得焦点，也无法提交
(提示：如果你想要修改2、3的readonly和disabled属性，让表单正常，那么就要直接删除这个属性：removeAttribute )

【@】重置表单元素：
1---<input type="reset" value="通用重置按钮">
2---<button type="reset">自定义重置按钮</button>
3---form元素.reset();	// 表单重置方法
(提示：所有表单元素都会恢复到初始化时的状态; 取消重置：event.preventDefault() )

【@】表单输入元素变化事件：
1---onchange：文本输入表单元素失去焦点并内容发生变化时触发
2---oninput： 键盘按键弹起就出发(IE8不支持)
3---onpropertychange：键盘按键弹起就出发(仅IE支持)

兼容写法：
if(document.all){				// document.all是IE浏览器页面所有元素的集合，可以用它来判断是不是IE浏览器
  表单元素.onpropertychange=function(){
    console.log('ie8浏览器')
  }
}else{
  表单元素.oninput=function(){
    console.log('其他浏览器')
  }
}

【@】表单字段：
1---获取页面中所有的表单元素：表单元素.elements
2---获取页面中指定的表单元素：表单元素.elements['name值']  或者  表单元素.name值
3---建议用 表单元素.elements['name值']去访问表单元素，因为通过 表单元素.name值 这种形式访问表单元素是为了与旧版本浏览器向后兼容的过渡方式

【@】表单元素主动获得焦点：autofocus
<input type="text" value="" autofocus>

[实例]：仿表单序列化，提交时向后台发送对象数据(了解即可)
window.onload=function(){
	var forms=document.forms['form1'];
	var oBtn=document.getElementById('submitBtn');

	oBtn.onclick=function(){
		var Elements=forms.elements;
			var obj={};
			var arrRadio=[];

			for(var i=0; i<Elements.length; i++){
				if( Elements[i].type=='text' || Elements[i].type=='textarea' ){
					obj[Elements[i].name]=Elements[i].value;
				};
				if( Elements[i].type=='radio' ){
					arrRadio.push(Elements[i].checked);
					obj[Elements[i].name]=arrRadio;
				};
				if(Elements[i].type=='checkbox'){
					obj[Elements[i].name]=Elements[i].checked;
				};
			};
			console.log(obj)
	};
};

【@】项目中判断用户在input框中输入的是不是纯数字：书籍419页用详细代码

【@】select添加选项方法：
1---可以用原生的方式去添加

2---Option构造函数，select的add方法添加
var oForm=document.getElementById('forms');		// 获取表单元素
var newOption=new Option('内容'，value值);		// 创建Option构造函数，传入选项名
oForm.elements['selects'].add(newOption,undefined);	// 添加到指定的select元素最下面

【@】select移除选项方法：select元素.remove(索引)


【表单序列化原生版】：输出字符串类型 (书籍436页)
function serialize(form) {
    var parts = [],
        field = null,
        i,
        len,
        j,
        optLen,
        option,
        optValue;

    for (i = 0, len = form.elements.length; i < len; i++) {
        field = form.elements[i];

        switch (field.type) {
        case "select-one":		// select单选框
        case "select-multiple":		// select多选框

            if (field.name.length) {
                for (j = 0, optLen = field.options.length; j < optLen; j++) {
                    option = field.options[j];
                    if (option.selected) {
                        optValue = "";
                        if (option.hasAttribute) {
                            optValue = (option.hasAttribute("value") ? option.value : option.text);
                        } else {
                            optValue = (option.attributes["value"].specified ? option.value : option.text);
                        }
                        parts.push(encodeURIComponent(field.name) + "=" + encodeURIComponent(optValue));
                    }
                }
            }
            break;

        case undefined:
        case "file":
        case "submit":
        case "reset":
        case "button":
            break;

        case "radio":
        case "checkbox":
            if (!field.checked) {
                break;
            }
            /* 执行默认代码 */

        default:
            //不包含没有名字的表单字段
            if (field.name.length) {
                parts.push(encodeURIComponent(field.name) + "=" + encodeURIComponent(field.value));
            }
        }
    }
    return parts.join("&");
};


【表单序列化JQ版】：输出json格式
$.fn.serializeJson=function(){
    var serializeObj={};
    var array=this.serializeArray();
    var str=this.serialize();
    $(array).each(function(){
        if(serializeObj[this.name]){
            if($.isArray(serializeObj[this.name])){
                serializeObj[this.name].push(this.value);
            }else{
                serializeObj[this.name]=[serializeObj[this.name],this.value];
            }
        }else{
            serializeObj[this.name]=this.value;
        }
    });
    return serializeObj;
};

$("#表单元素ID").bind("submit",function(e){
    e.preventDefault();
    console.log( $(this).serializeJson() );
});


/*-------------------------------------------------------end 表单脚本------------------------------------------------------*/


/*---------------------------------------------------错误处理与调试(17章)--------------------------------------------------*/

【@】错误处理语句：
1---try{}catch(e){}
try {
    // 可能报错的代码
} catch(e) {
    // 后台打印错误信息：console.log(e);
}

2---try{}catch(e){}finally{}
try {
    // 可能报错的代码
} catch(e) {
    // 后台打印错误信息：console.log(e);
} finally {
    // 一定会执行的语句
}

【@】javascript中的7种报错类型：书籍501页
1---Error
2---EvalError
3---RangeError:		数值超出范围时触发
4---ReferenceError:	访问不存在或未定义的变量时触发  (变量名 is not defined)
5---SyntaxError
6---TypeError:		在变量中保存意外的类型或者访问不存在的属性或方法时触发  (Cannot read property '属性或方法' of undefined)
7---URIError

【@】判断错误类型，并执行相应程序：
try {
    // 可能报错的程序
} catch(error) {
    if(error instanceof TypeError){
        console.log('在变量中保存意外的类型或者访问不存在的属性或方法时触发')
    }else if(error instanceof ReferenceError){
        console.log('访问不存在或未定义的变量时触发')
    }else{
        console.log('其他错误')
    }
};

【@】模拟浏览器主动报错：throw (书籍504-505页)
throw主动抛错的处理机制，一般在自己写的函数里面执行，用来判断函数执行失败时可能的错误信息

【@】错误事件：onerror，只要发生错误，无论是不是浏览器生成的，都会触发window的onerror事件
window.onerror=function(message,url,line){
    console.log(message)	// 错误信息
    console.log(url)		// 错误url地址
    console.log(line)		// 错误所在的行间数
}

/*-----------------------------------------------------end 错误处理与调试--------------------------------------------------*/


/*---------------------------------------------------------JSON(20章)-----------------------------------------------------*/

【@】在JSON出现之前XML是服务器端存储数据和传输数据的王道，后来JSON出现了，JSON是一种数据格式，不是一种编程语言，很多编程语言都有JSON数据

【@】JSON数据的两种方法
1---JSON.stringify(数据)		// 将前端的JSON对象转换成后台可以用的JSON数据
2---JSON.parse(数据)		// 将接收到的后台JSON数据转换成前端可以用的数据

【@】JSON数据的筛选(只针对前端传入到后台的数据)
var book={
    "title":"书籍名称",
    "edition":3,
    "year":2017
};
var jsonBook=JSON.stringify( book,["title","year"] )
console.log(jsonBook)   // {"title":"书籍名称","year":2017}

【@】JSON数据做筛选并做其他处理(只针对前端传入到后台的数据)
var book={
    "title":"书籍名称",
    "edition":3,
    "year":2017
};
var jsonBook=JSON.stringify( book,function(key,value){
    switch (key) {
        case "title":
            return value.charAt(0);
            break;
        case "year":
            return value*3;
            break;
        default:
            return value;
            break;
    }
} );
console.log(jsonBook)   // {"title":"书","edition":3,"year":6051}


/*----------------------------------------------------------end JSON------------------------------------------------------*/

/*------------------------------------------------------ajax与Comet(21章)-------------------------------------------------*/

【@】前言：
要讲清楚Comet是什么的问题？我不妨将话题扯远点，我们先了解下web开发的历史。
大家一定还记得从前，我们在论坛注册账号，一点了提交按钮，页面就一片空白（服务器在刷新页面，处理提交数据），ie的状态图就不停的转，
一个提交按钮一点，页面就再也不能进行其他操作了（因为这里的数据请求和界面操作是同步的）。我们就傻等着服务器处理完数据后返回，以前网速也慢，服务器性能也差。那么这个等待时间就会挑战大家的容忍极限。这个就是Ajax诞生要解决的问题。

其实在Ajax这个名字没有出现的时候，‘Ajax’的应用就已经存在了。那时前辈们就已经在WEB方面为追求更完美的用户体验，为追求异步通信，为追求局部刷新摸索出了一些可重用的方式方法。大致方法有2种：
1---页面中放入一个隐藏的frame 页面，这个页面有一个表单form对象。而数据的提交，就交给这个 frame 页面。就算是刷新也是这个页面刷新，而这个页面由于是隐藏的或者高度和宽度设置为0的，所以刷新时候用户感觉不到。那么当数据返回的时候也就能够达到局部刷新的效果。而且用户操作的页面不用被卡住，这样也达到异步通信的效果了。这种是比较古老和麻烦的方法。
2---开发人员开发自己的ActiveX 控件，这个控件的功能基本和现在Ajax 差不多，其实Ajax 大家也可以看成是一个ActiveX 控件，只是各大浏览器都实现了这个ActiveX 控件。所以现在我们开发Ajax应用，不用自己开发这个ActiveX 控件。Ajax实现了对XMLHTTP对象的封装，这个对象有一系列接口，比较重要的是发送异步数据的接口。


【@】Comet的诞生历史：
当服务器端数据发生变化时，客户端如何即时得到通知呢？这个就是Comet诞生的背景。
1.  传统方法定时刷新，就是隔一个时间段浏览器刷新一次。（没有用户受得了这种方法，服务器也害怕遇到这种事情）

2.  长轮询（long-polling）Ajax隔一段时间就去服务器查询是否有更新，但是多长时间去查询成了问题。因为性能和即时性造成了严重的反比关系。

3.在前面两种方法被否定后，想到了服务器推送至客户端这种模式，但是web开发客户端是一个浏览器（并不是我们自己控制的GUI客户端）。
所以Comet登场，简单说还是利用Ajax与服务器建立http长连接查询是否有数据更新，服务器收到一个连接如果没有数据更新就阻塞这个连接不要返回给客户端，直到有新数据再返回给客户端。
Web客户端，发起的连接一旦被返回，或者超时就再次建立http长连接。这样就能保证数据的即时更新，以及尽量减少服务器的计算工作。


【@】Comet的一些应用
目前Comet主要应用在一些股票web客户端，或者现在比较流行的 "弹幕"，以及一些基于web的即时聊天系统中。比较成熟的框架有Dojo ，Dwr 等一些Ajax框架中实现了该功能。

1---优点  
实时性好（消息延时小）
性能好（能支持大量用户）

2---缺点  
长期占用连接，丧失了无状态高并发的特点。
server push不会是一个没有副作用的解决方案，是否适合还要仔细权衡。


/*-------------------------------------------------------end ajax与Comet--------------------------------------------------*/


/*------------------------------------------------------高级技巧(第22章)--------------------------------------------------*/

【@】安全的类型检测：Object.prototype.toString.call()  它是根据构造函数来判断类型的

【@】作用域安全的构造函数
1---this指向
function Person(name,age){
    this.name=name;
    this.age=age;
};
var person1=Person('小明',20);
console.log(window.name)	// 小明
console.log(person1.name)	// 报错

2---安全的this指向(让构造函数里面的this始终指向创建出来的对象)
function Person(name,age){
    if(this instanceof Person){
        this.name=name;
        this.age=age;
    }else{
        return new Person(name,age);
    }
}
var person1=Person('小明',20);
console.log(window.name)	// ''
console.log(person1.name)	// 小明


【@】防止对象被篡改：Object.preventExtensions(obj)
var obj={
    name:'小明',
    age:20
}
Object.preventExtensions(obj);	
obj.name='小红';			
obj.sex='女';

alert(obj.name);	// 小红		--> 对象原来已经存在的属性或方法是可以被修改或删除的	
alert(obj.sex);		// undefined    --> 对象原来不存在的属性或方法是不可以被添加的	

【@】防止对象被篡改和删除：Object.preventExtensions(obj)
var obj={
    name:'小明',
    age:20
}
Object.seal(obj)

obj.name='小红';          
obj.sex='女';

delete obj.name;	

alert(obj.name);    // 小红		--> 对象原来已经存在的属性或方法是可以被修改的，但不能删除
alert(obj.sex);     // undefined	--> 对象原来不存在的属性或方法是不可以被添加的

【@】最严格的防止篡改和删除对象的方法：Object.freeze(obj)
var obj={
    name:'小明',
    age:20
}
Object.freeze(obj)		// obj对象被冻结，无法做任何添加、修改、删除操作

obj.name='小红';          
obj.sex='女';

delete obj.name;

alert(obj.name);    // 小明		
alert(obj.sex);     // undefined	


【@】定时器setTimeout去执行连续的事情:
setTimeout(function(){
    var oDiv=document.getElementById('div');
    var L=parseInt(oDiv.offsetLeft);
    L++;
    if(L<100){ setTimeout(arguments.callee, 30) }else{ arguments.callee=null; };
    oDiv.style.left=L+'px';
}, 30);


【@】函数节流：某些代码不可以在没有间断的情况下连续重复执行
// 连续触发事件
window.onresize=function(){
	throttle(sum)
};

// 要执行的函数
function sum(){ console.log('执行函数') }

// 封装函数节流方法
function throttle(fn,context){
	clearTimeout(fn.timer);
	fn.timer=setTimeout(function(){
		fn.call(context);
	},100);
}


【@】惰性函数：
在一个函数声明中，如果有if等条件判定语句的话，那么每次在执行这个函数的时候都会进行判定后在处理。
比如：判定浏览器类型（能不能判定一次之后就不在判定浏览器类型了，从而优化执行过程，提高性能）
function isIE(){
	if(document.all){
		alert('这个是IE浏览器')
	}else{
		alert('这个不是IE浏览器')
	}
};

[改写上面函数]：声明变量，初始加载时，给变量一个确定的值，之后的加载将不会在自执行函数了，提高性能
var isIE=(function(){
	if(document.all){
		return function(){
			// 执行代码
		}
	}else{
		return function(){
			// 执行代码
		}
	}
})();
isIE();


/*--------------------------------------------------------end 高级技巧----------------------------------------------------*/


/*-------------------------------------------------HTML5 离线应用与客户端存储----------------------------------------------*/
 
【@】支持离线Web应用开发是HTML5的一个重点，所谓离线web应用，就是在设备端网的情况下依然可以运行应用。
前端开发人员一直希望web应用能够与传统的客户端应用进行同场竞技，起码做到只要设备有电就能够使用web应用。

【@】H5离线缓存
离线缓存：它可以让Web应用在离线的情况选继续使用，通过manifest文件指明需要缓存的资源 
H5离线缓存如何更新：如果有修改资源文件，必须通过修改mainfest文件来刷新被缓存的文件列表

【@】数据存储cookie
1---由于所有的cookie都会由浏览器作为请求头发送，所以在cookie中存储大量信息会影响到特定域的请求性能。cookie信息越大，完成对服务器请求的时间也就越长。尽管浏览器对cookie大小进行了限制，
不过最好还是尽可能在cookie中少存储信息，以避免影响性能。
2---注意：一定不要在cookie中存储重要和敏感的数据。cookie数据并非存储在一个安全环境中，其中包含的任何数据都可以被他人访问。所以不要在cookie中存储像信用卡号或者个人地址之类的数据。

【@】本地存储
1---HTML5中与本地存储相关的两个重要内容：Web Storage与本地数据库。
2---Web Storage的目的是克服由cookie带来的一些限制，当数据需要被严格控制在客户端时，无需持续地将数据发回服务器。
3---本地数据库使得原本必须保存在服务器端数据库中的内容现在可以直接保存在客户端本地了，这大大减轻了服务端的负担，同时也加快了访问数据的速度。

（更多详情：http://blog.csdn.net/liujie19901217/article/details/50965838）

/*--------------------------------------------------end 离线应用与客户端存储-----------------------------------------------*/





/*--------------------------------------------加载和执行(第一章)------------------------------------------------*/
【@】javascript的阻塞特性：
1---在浏览器加载javascript的时候，不能做其他任何事情，也就是说javascript的加载时间越久，浏览器相应的时间也就越久，这个时候页面是空白的（body还没有加载）
2---无论当前的javascript是内嵌在body里面的（可以是任何位置），还是用src外链的，页面的渲染都是流式自上而下加载，遇到script标签时会阻塞下面html的加载
<body>
	<p>文字内容</p>
	<script> 执行代码 </script>	// 浏览器不知道你这里的js要对页面作何处理，所以在加载完p标签后，会加载这个script标签，阻塞script标签下面的html元素的加载，直到加载完成
</body>

【@】脚本位置：
推荐将script标签尽可能的放在body标签的最下面，而css文件放在head标签里面，这样可以先显示页面结构和样式，让用户觉得速度变快

【@】脚本数量：
1---对于外链的javascript脚本，每次HTTP请求都会造成性能的损失（下载一个100kb的js文件，要比下载4个25kb的js文件要快），所以减少js文件的外链请求数量是可以改善性能的
2---方式1：合并js脚本文件    方式2：用打包工具让一个script标签里面的src去引入一个http请求，但可以同时下载多个js文件

【@】延时脚本：注意这个些script标签都要在head里面
1---defer属性：采用并行下载，不会阻塞后面脚本的下载，但被defer属性作用的script文件都要等待body标签里面DOM加载完成后，onload事件触发之前，才会执行 （先下载，后执行）
2---async属性：采用并行下载，不会阻塞后面脚本的下载，但被async属性作用的script文件在下载完成后会马上自动执行（下载完成后马上执行）

[实例]：
<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<title>Document</title>
	<script src="cs.js" defer></script>	// 这个js文件里面有 alert('defer') 代码
</head>
<body>
	<script>
		alert('script')
	</script>
	<script>
		window.onload=function(){
			alert('onload')
		}
	</script>
</body>
</html>  

执行结果：script  defer  onload

/*--------------------------------------------end(第一章)------------------------------------------------*/

/*--------------------------------------------数据存取(第二章)------------------------------------------------*/

【@】在函数中使用变量去保存执行环境作用域链最外层的对象
function fn(){
	var oBox=document.getElementById('box');
	document.onclick=function(){
		document.wirte('xxx')
	};
}

[改写]：
function fn(){
	var doc=document;			// 保存最外层的document对象
	var oBox=doc.getElementById('box');
	doc.onclick=function(){
		doc.wirte('xxx')
	};
}

/*--------------------------------------------end(第二章)------------------------------------------------*/

/*--------------------------------------------DOM编程(第三章)------------------------------------------------*/

【@】DOM编程为啥这么慢：
浏览器通常会把DOM和javascript独立实现，都保存在内存中的独立位置里面，可以把它们两者比作两个小岛，
它们之间要进行连接的话，就必须通过一座收费的桥，所以DOM操作越多，费用也就越多

【@】重排&重绘：
浏览器下载完页面的所有组件(html标签、css、js、img地址)，之后会生成两个数据机构：
1---DOM树： 表示页面的结构
2---渲染树：表示DOM节点该如何显示(比如：宽度、高度、位置、背景、颜色等等)

【@】重排：涉及到元素几何形状的样式改变
当DOM元素的变化影响了元素的几何形状时(宽度、高度、页面布局)--比如改变宽度或给段落添加了内容而导致元素高度变化等，浏览器需要重新计算该元素的几何属性，
同样其他元素的几何属性和位置也可能受到影响。这个时候浏览器会对受到影响的部分的渲染失效，并重新构建渲染树，这个过程称之为重排。

【@】重绘：不涉及到元素几何形状的样式的改变
浏览器对受到重排影响的部分进行重新绘制，这个过程称之为重绘。
但是，并不是所有的DOM变化都会引起重排，比如改变元素的背景色(不影响元素的几何形状),它只会引起重绘

【@】重排何时发生：当页面布局或元素几何形状发生变化
1---添加或删除DOM元素
2---元素位置变化
3---元素几何形状变化(宽度或高度)
4---窗口大小变化
5---初始加载或页面高度变化导致滚动条出现(整个页面都会重排)
6---获取页面布局信息的js操作

[第6点解释]：
1---用js获取页面元素的布局位置或几何形状时(宽度或高度)：比如 offsetLeft、clieatWidth、scrollTop、getComputedStyle等属性或方法
2---以上属性和方法的使用都会触发重排，所以在修改样式的时候，尽量避免使用这些属性或方法

[实例]：
var oDiv=document.getElementById('div');
oDiv.style.width='100px';
oDiv.style.padding='10px';
(上面的代码可能在低版本浏览器里面造成两次重排，高版本浏览器只触发一次重排)

[改写上面实例]：
var oDiv=document.getElementById('div');
oDiv.style.cssText=' width:100px; padding:10px; ';
(上面的代码在所有浏览器里面只造成一次重排)

【@】最小化减少重排和重绘：
1---先隐藏元素、对隐藏后的元素进行处理、最后显示元素 (因为隐藏后的元素不会触发重排和重绘)
2---先复制一份要处理的元素节点、然后对复制的那个元素进行处理、最后在替换掉当前元素
3---如果某个元素它有动画效果，同时可能造成页面其他元素的位置或几何形状发生变化时，可以考虑对元素用绝对定位属性，让它脱离文档流，这样重排和重绘就只发生在它一个人身上


/*--------------------------------------------end(第三章)------------------------------------------------*/
























/*---------------------------------封装EventUtil对象-----------------------------------*/

var EventUtil={
	// 获取event对象
	getEvent: function (event){
		return event ? event : window.event;
	},
	// 获取event对目标元素
	getTarget: function (event){
		return event.target || event.srcElement;
	},
	// 阻止默认行为
	preventDefault: function (event) {
		if (event.preventDefault) {
			event.preventDefault();
		}else{
			event.returnValue = false;
		};
	},
	// 阻止事件捕获和冒泡
	stopPropagation: function (event){
		if (event.stopPropagation){
			event.stopPropagation();
		}else{
			event.cancelBubble = true;
		};
	},
	// 给DOM元素添加指定事件(事件不加on关键字)
	addHandler: function (element, type, handler){
		if (element.addEventListener){
			element.addEventListener(type, handler, false);
		}else if (element.attachEvent){
			element.attachEvent('on'+type, handler)
		}else{
			element['on'+type] = handler;
		};
	},
	// 给DOM元素添加事删除指定事件(事件不加on关键字)
	removeHandler: function (element,type,handler){
		if (element.removeEventListener){
			element.removeEventListener(type,handler,false);
		}else if (element.detachEvent){
			element.detachEvent('on'+type,handler)
		}else{
			element['on'+type]=null;
		};
	},
	// 获取发生在文本输入框keypress事件中的输入字符编码
	getCharCode: function (event){
		if (typeof event.charCode == 'number'){
			return event.charCode;
		} else{
			return event.keyCode;
		}
	},
	// 获取复制"操作得到的文本信息(针对文本输入框中的"paste粘贴"操作)
	getClipboardText: function (event){
		var clipboardData = (event.clipboardData || window.clipboardData);
		return clipboardData.getData('text');
	},
	// 获取鼠标按下那个键(左键0、中间键1、右键2)
	getButton: function (event){
		if (document.implementation.hasFeature('MouseEvents', '2.0')){
			return event.button;
		} else {
			switch (event.button){
				case 0:
				case 1:
				case 3:
				case 5:
				case 7:
					return 0;
				case 2:
				case 6:
					return 2;
				case 4:
					return 1;
			}
		}
	},
	// 获判断鼠标滚轮上下滚动(上滚: true; 下滚：false)
	getWheelDelta: function (event){
		var direction = true;
		if ( event.wheelDelta ){
			direction = event.wheelDelta > 0 ? true : false;
		};
		if ( event.detail ){
			direction = event.detail < 0 ? true : false;
		};
		if ( direction ){
			typeof upFn === "function" && upFn(event);
		} else {
			typeof downFn === "function" && downFn(event)
		};
		if ( event.preventDefault ){ event.preventDefault() };
		event.returnValue = false;
		return direction;
	}
};






















