【1】什么是AngularJs？
1、诞生于2009年，基于javascript开发的客户端应用前端框架，使我们可以更加快捷、简单的开发WEB应用。
2、适用于CRUD应用或者SPA单页网站开发。
CRUD:CRUD是指在做计算处理时的增、删、改、查数据。主要被用在描述软件系统中数据库或者持久层的基本操作功能。
SPA：单页Web应用，就是只有一张Web页面的应用，是加载单个HTML 页面并在用户与应用程序交互时动态更新该页面的Web应用程序。

【2】AngularJs的特性
1、MVC模式
2、模块系统
3、指令系统
4、依赖注入
5、双向数据绑定(MVVM)
6、脏检查机制(所有带有ng-开头的指令都会触发脏检查)

【3】MVC?
M:数据	V:视图	C:关联M和V的桥梁(ng-controller="")
[实例1]：
<!DOCTYPE html>
<html ng-app>	
<head>
	<meta charset="UTF-8">
	<title>Angularjs</title>
	<script src="./js/angular.min.js"></script>
	<script>
		function Aaa($scope){	
			$scope.name='hello';
			$scope.age='20';
		};
	</script>
</head>
<body>
	<div ng-controller='Aaa'>	
		<p>{{name}}</p>		
		<p>{{age}}</p>
	</div>
</body>
</html>

-----------------------------------------------------------------------------------------------------------
【1】anglarjs中的指令系统：ng-xxx
1、ng-app：初始化指令，否则anglarjs无法执行，它可以写在html里面的任何地方，他有局部和全局之分，写在html里面表示全局，在其他html标签里面表示局部。
2、ng-controller：表示MVC中的C，起到关联M和V的作用

【2】作用域：$scope 和 $rootScope的区别
1、$scope：局部对象，只能在当前和内部使用
2、$rootScope：全局对象，不管在哪个函数里面，全局下都可以使用，并且优先级小于局部对象中的变量

【3】依赖注入
当我们在html标签上加入 ng-controller="Aaa"的时候，其实是angularjs在它的内部调用了Aaa这个函数，它的行参是anguljs规定好了的，是不允许被修改的。

【4】双向数据绑定：MVVM
1、意思为：当数据变化时，视图也变化；而视图变化时也会改变数据。
[实例1]：M影响V的变化---1s后改变数据，同时改变视图
<script>
	function Aaa($scope,$timeout){
		$scope.name="hello";
		$timeout(function(){
			$scope.name="hi";
		},1000);
	};
</script>
<div ng-controller='Aaa'>
	<p>{{name}}</p>
</div>
(提示：原生的setTimeout定时器不具备数据交互的功能，所以必须引用$timeout对象才行)

[实例2]：M影响V的变化---点击DIV，视图变化，数据跟着变
function Aaa($scope,$timeout){
	$scope.name="hello";	
};
<div ng-controller='Aaa' ng-click=" name='hi' ">
	<p>{{name}}</p>
</div>
(提示：ng-click=" name='hi' " 表示当div点击时，改变Aaa函数里面的name数据，它也可以写成函数的方式，如下)

function Aaa($scope,$timeout){
	$scope.name="hello";
	$scope.show=function(){
		$scope.name="hi";
	};	
};
<div ng-controller='Aaa' ng-click=" show() ">
	<p>{{name}}</p>
</div>
（提示：除了有ng-click以外，还有和原生js一样的其他事件，比如ng-mouseover等等）

[实例2]：V影响M的变化---input输入内容时改变数据 
<div ng-controller="Aaa">
	<input type="text" ng-model="name">
	<p>{{name}}</p>
</div>
（提示：ng-model="name" 的意思为，开始name数据输入input里面，但input内容变化时，在反输出给name，从而改变数据name）

[实例4]currency 过滤器，angularJS给我们提供了一套辅助程序，用来辅助输出结果用的，比如金额显示等
默认显示 $,如果你想改掉默认的，那么就这么写 currency:"￥"
<p>费用：<span>{{ iPone.money*iPone.num | currency }}</span></p>

[实例3]金额计算 （下面还有个写法，考虑到费用如果输出的时候表达试过长的问题）
<script>
	function Aaa($scope){
		$scope.iPone={
			money:5,	//价格
			num:1,		//数量
			fre:10		//运费
		};
	};
</script>
<div ng-controller="Aaa">
	<p>价格：<input type="text" ng-model="iPone.money"></p>
	<p>数量：<input type="text" ng-model="iPone.num"></p>
	<p>费用：<span>{{iPone.money*iPone.num | currency:"￥" }}</span></p>
	<p>总额：<span>{{ iPone.money*iPone.num + iphone.fre | currency:"$" }}</span></p>
</div>

<script>
	function Aaa($scope){
		$scope.iPone={
			money:5,
			num:1,
			fre:10
		};
		$scope.sum=function(){
			return $scope.iPone.money*$scope.iPone.num;
		};
	};
</script>
<div ng-controller="Aaa">
	<p>价格：<input type="text" ng-model="iPone.money"></p>
	<p>数量：<input type="text" ng-model="iPone.num"></p>
	<p>费用：<span>{{ sum() | currency:"$" }}</span></p>
	<p>总额：<span>{{ sum()+iphone.fre | currency:"$" }}</span></p>
</div>

【5】$watch() 监听事件
1、当函数中的某个值发生变化时，去执行对应的函数，它是$scope下面的一个方法，并且自执行

2、$watch()，可以接收三个参数，前两个必选，最后一个可选
   用法：$scope.$watch('监听对象'，function(){})
   比如上面的金额计算里面，如果价格发生变化时，做相应的事件
   $scope.$watch('iphone.money',function(){
	 console.log(1)
   });

3、$watch()它默认是单值监听，如果把第三个参数写为true，就可以实现多值监听，比如
$scope.$watch('iphone',function(){
	console.log(1)
},true);
这样iphone下面的任何一个单值变化时，都会触发函数

4、$watch()的第二个回调函数可以接收3个参数，其中前两个表示新的值和老的值
$scope.$watch('iphone.money',function(newV,lodV){
	console.log(newV,lodV);
});

5、$watch()除了可以监听字符串以外，还能监听函数(函数前面必须加入$scope)
$scope.$watch($scope.sum,function(newV,lodV){
	if(newV >= 6050 ){
		$scope.iphone.fre=0;
	}else {
		$scope.iphone.fre=10;
	};
});
(这就表示：监听函数sum的执行结果，如果结果>=6050的时候，就免运费，否则运费为10块)

【6】模块化开发 angular.module()
1、因为在实际合作开发中，是一定会用模块去开发的，所以为了防止你和其他人写的函数名一样而造成的函数覆盖。

2、它接收两个参数，第一个是你自己起的名字，二是依赖其他 的js文件，如果没有依赖就写空数组
   var m1=angular.module('myApp1',[]);
   然后在ng-app里面引入你写的模块<html ng-app="myApp1">

var m1=angular.module('myApp1',[])
m1.controller('Aaa',function($scope){
	$scope.name="div1";
});

3、因为在线上是压缩的文件，所以$scope这个参数会被压缩，导致代码出错，所以要改写代码，让第二个参数为数组，第一个值为字符串"$scope",即可。
var m1=angular.module('myApp1',[]);
m1.controller('Aaa',['$scope',function($scope){
	$scope.name="div1";
}]);


-----------------------------------------【angularJs工具方法】-----------------------------------------
1、angular.bind 
2、angular.copy
3、angular.extend
4、angular.version
5、angular.equals
6、angular.forEach
7、angular.fromJson/toJson
8、angular.identity/noop
9、angular.lowercass/uppercase
10、angular.element
11、angular.bootstrap
12、angular.injector
13、ng-include



[1]---:angular.bind()  更改函数中的this指向
function show(num1,num2){
	alert(this);
};
angular.bind(doucment,show)(1,2);
(提示：在执行show函数时，把函数里面的this指向doument，参数传人1,2到num1和num2中)

[2]---:angular.copy()拷贝对象
var a={name:"a"};
var b={age:20};
angular.copy(a，b);
console.log(a)	--{name: "a"}
console.log(b)	--{name: "a"}
a把值拷贝给了b，而b在拷贝之前先清空自己(谁在前面变成谁)

[3]---:angular.extend()继承对象
var a={name:"a"};
var b={age:20};
angular.extend(a，b);
console.log(a)	--{name: "a", age: 20}
console.log(b)	--{age: 20}
a继承了b的所有值	

[8]---angular.identity/noop;
1--angular.identity(参数);	--它返回的还是str本身
var str='hello';
console.log( angular.identity(str) )

2--angular.noop();	--它返回的是 undefind

(提示：它们好像没什么用，其实它们是在程序中起到辅助作用的，比如，你的参数不写的时候，输出的程序有可能报错，但如果用或的方式写了辅助参数的话，就不会报错)

[9]---angular.lowercase/uppercase；大小写转换
var str='hello';
console.log( angular.uppercase(str) )

[10]---angular.element();获取元素  ---了解即可
其实在angularJs中融入了一些常用的jquery的方法；
var oDiv=document.getElementById('div');
angular.element(oDiv).css('background','red');
<div id="div">div</div>

angular.element('#div').css('background','red');
(提示：如果先引入jquery文件的话，那么 angular.element其实就和jquery中的$一样了，也就可以改写成上面的写法)

[11]---angular.bootstrap()；动态去执行angularJs（当你想什么执行angularJs时在执行）
document.onclick=function(){
	angular.bootstrap(document,['myApp']);
};
点击页面时，在doucment文档中执行angularJs，其实和它是一样的效果 <html ng-app="myApp">
这样做的目的是，在和其他前端框架库结合使用时，可以更加灵活的去执行angularJs的操作。其次就是，在你和其他人写的angularJs模块中，可以使用更加灵活（不常用）

[12]---angular.injector(); 这个方法其实是在angularJs内部使用的，在外部不怎么用。

[13]---ng-include 加载另外的html页面(chorm有兼容问题，建议在环境下使用)
<div>页面</div>
<div ng-include="'页面名称.html'"></div>


【$scope对象下的两个方法】：$watch()、$apply()
1、$watch() 监听事件
2、$apply() 在原生js里面去执行angularJs里面的一些方法
var m1=angular.module('myApp',[]);
m1.controller('Aaa',['$scope',function($scope){
	$scope.name="小明";

	setTimeout(function(){
		$scope.$apply(function(){
			$scope.name="小米";
		});
	},1000);
}]);
（提示：原生的setTimeout其实是要用 $timeout去替代才能使用的，但有时候不想那么麻烦，所以可以用$scope.$apply（function(){xxx}去直接执行））

【13】angular.fromJson    angular.toJson
1---angular.fromJson()方法可以把一个Json字符串中解析成一个对象，或对象数组：
var json = '{"name":"liSi", "password":"321"}';  
var jsonArr = '[{"name":"zhangSan", "password":"123"},{"name":"liSi", "password":"321"}]';  
var J=angular.fromJson(json);	//J={name: "liSi", password: "321"}

2---angular.toJson()  从对象到Json字符串
var obj =  {  name:"liSi", password:"321"  }  
var str = angular.toJson(obj, true);  

【14】angular.forEach(); angularJs自带循环系统,循环数组用的.angular有自己的生命周期。循环给一个 angular监听的变量复值时。最好还是用angular自带的循环方式.
var objs =[{a:1},{a:2}];
angular.forEach(objs, function(data,index){
	console.log(data);	Object1 {a: 1}
  Object2 {a: 2}
	console.log(index);	0  1
});
objs:需要遍历的集合,建议使用数组对象
data:遍历时当前的数据
index:遍历时当前索引。


【angular.module下面的两个方法】controller()、run()
1---controller()  局部作用域，在上面有介绍
<html ng-app="myApp">....
var m1=angular.module('myApp',[]);
m1.controller('Aaa',['$scope',function($scope){xxx}]);

2---run()	创建全局的变量，他比controller先执行
<html ng-app="myApp">....
var m1=angular.module('myApp',[]);
m1.run(['$rootScope',function($rootScope){xxx}]);
这样就创建了全局的变量，在整个页面都是共享的数据。


---------------------------------【angularJs中的过滤器】---------------------------
1、currency
2、number
3、lowercase/uppercase
4、json
5、limitTo
6、date
7、orderBy
8、filter

1---currency："$"	货币金额换算（默认为 $）(如果带小数，它默认保留2位)
<p>金额：{{ name | currency:"￥"}}</p>		//金额：￥231,656.00

2---number	金额换算，如果后面有小数点，默认只保留3位(四舍五入)，可以通过 number:2 的形式修改保留位数。
<p>金额：{{ name | number:2 }}</p>		//金额：231,65(保留2位小数点)

2---lowercase/uppercase		大小写转换

3---json	转换成json格式输出，方便调试，注意要由<pre></pre>标签去做
$scope.name={"name":"hello","age":"20"};
<pre>{{ name | json }}</pre>
最后输出成：
{
  "name": "hello",
  "age": "20"
}

4---limitTo	字符串,数组截取（默认全部截取）
$scope.name='hello';
<p>截取：{{ name | limitTo:2 }}</p>	//he

5---date	日期格式化(毫秒数)，它下面有很多参数可选，具体参照百度
$scope.name='516132165161';
<p>时间：{{ name | date:'fullDate' }}</p>

6---orderBy	数据排序(数据必须是数组中用json的格式才能起作用，比如：)
$scope.name=[
	{color:'red',age:10},
	{color:'yellow',age:20},
	{color:'blue',age:30},
	{color:'black',age:40}
];
<p>排序：{{ name | orderBy:'age' }}</p>		//默认从小到大排序
时间：[{"color":"red","age":10},{"color":"yellow","age":20},{"color":"blue","age":30},{"color":"black","age":40}]

<p>排序：{{ name | orderBy:'age':true }}</p>	//如果要从大到小排序，就添加参数true
时间：[{"color":"black","age":40},{"color":"blue","age":30},{"color":"yellow","age":20},{"color":"red","age":10}]

7---filter	过滤、筛选(主要针对key值，可以是整体，也可以是部分) 数据和6一样
<p>过滤：{{ name | filter:'re' }}</p>		//过滤：[{"color":"red","age":10}]
如果写成入第三个参数true,就代表匹配整体的value值
<p>过滤：{{ name | filter:'key值':true }}</p>

--------------------------------【过滤器的扩展】------------------------------------
1、可以组合使用过滤器
2、JS中使用过滤器
3、自定义过滤器

[1]---可以组合使用过滤器
$scope.name="hello";
<p>过滤器组合：{{ name | limitTo:2 | uppercase }}</p>	//HE

[2]---JS中使用过滤器	服务对象：$filter
var m1=angular.module('myApp',[]);
m1.controller('Aaa',['$scope','$filter',function($scope,$filter){
	$scope.name=$filter('uppercase')('hello');	//HELLO
	$scope.name=$filter('limitTo')('hello',2);	//he
}]);
<div ng-controller="Aaa">
	<p>{{ name }}</p>	
</div>

[3]---自定义过滤器	模块angular.module 下面的filter方法
实现首字母大写的过滤器方法 angular.firstUp
var m1=angular.module('myApp',[]);
m1.filter('firstUp',function(){
	return function(str,num){
		//参数str其实就是数据 $scope.name,而num就是firstUp方法的参数
		return str.charAt(0).toUpperCase()+str.substring(1);
	};
});
m1.controller('Aaa',['$scope',function($scope){
	$scope.name="hello";
}]);
<div ng-controller="Aaa">
	<p>{{ name | firstUp }}</p>	//Hello
</div>	

【实例】
var m1=angular.module('myApp',[]);
m1.controller('Aaa',['$scope',function($scope){
	$scope.Data=[
		{
			name:'xiaoming',
			age:10,
			city:'上海'
		},
		{
			name:'xiaohong',
			age:20,
			city:'北京'
		},
		{
			name:'xiaofang',
			age:30,
			city:'杭州'
		}
	];
}]);
m1.filter('filterSX',function(){
	return function(obj,cn){
		var arr=[];
		angular.forEach(obj,function(data,index){
			if(data.age>=cn){
				arr.push(obj[index])
			}
		});
		return arr;
	}
});

<div ng-controller="Aaa">
	<p ng-repeat="data in Data | filterSX:15">
		{{data.name}},
		{{data.age}},
		{{data.city}}
	</p>
</div>

-----------------------------------【循环指令系统】-----------------------------------
1、ng-repeat
作用：通过in的方式遍历每一项（针对数组或数组对象）
var m1=angular.module('myApp',[]);
m1.controller('Aaa',['$scope',function($scope){
	$scope.dataList=['aaa','bbb','ccc'];
}]);
<div ng-controller="Aaa">
	<ul>	
		<li ng-repeat="data in dataList">{{data}}</li>
	</ul>
</div>
(提示：data是自己命名的，并且ng-repeat可以使用过滤器)
<li ng-repeat=" data in dataList | roderBy:'age' ">{{data}}</li>

[实例]表格操作：（具体代码参考自己写的）


【ng-repeat指令系统:扩展部分】
---$index
---$first
---$last
---$even
---$middle
---$odd
---ng-repeat-start
---ng-repeat-end

1、$index	返回索引值
<li ng-repeat="data in dataList">{{$index}}</li>

2、$first 	集合的第一项返回true,其他项为false
<li ng-repeat="data in dataList">{{$first}}</li>

<li ng-repeat="data in dataList" ng-class="{active:$first}">{{$first}}</li> //给第一个li添加class=“active”

3、$last 	集合的最后一项返回true,其他项为false
<li ng-repeat="data in dataList">{{$last}}</li> 

4、$middle	集合的首尾项返回false，其他项都为true

5、$even 	集合的基数项返回true,偶数项为false
<li ng-repeat="data in dataList">{{$last}}</li> 

6、$odd		和$even相反

[实例]隔行变色：
.active1{ background:red; }
.active2{ background:blue; }
<ul>	
	<li class="{{ $odd?'active1':'active2' }}" ng-repeat="data in dataList">{{$odd}}</li>
</ul>

7、ng-repeat-start   ng-repeat-end	循环兄弟节点
<div ng-repeat-start="data in dataList">{{data}}</div>
<p>{{data}}</p>
<div ng-repeat-end>{{data}}</div>
（提示：它会在start和end之间来回循环，里面的data数据都是可以共用的）


-----------------------------------【事件触发指令系统】-----------------------------------
【与原生事件的区别】angular的事件支持表达式和变量的写法,并且监听的ng-事件必须加载到$scope对象下面。
   如：1--<div ng-click=" name='hi' ">{{name}}</div>
       2--<div ng-click=" show() ">{{name}}</div>
1、ng-click/dblclick
2、ng-mousedown/up
3、ng-mouseenter/leave
4、ng-mouseover/over/out
5、ng-keydown/up/press
6、ng-focus/blur
7、ng-submit
<div ng-click="events()"></div>
【实例】$event    
$scope.show=function(event){
	angular.element(event.target).html('asdfasdf')	//event.target:事件源
};
<div ng-click="show($event)">div</h1>
(以上事件指令和原生JS一样的用法)

8、ng-selected
9、ng-change
10、ng-copy
11、ng-cut
12、ng-paste

[1]ng-selected		选择框的触发指令
<input type="checkbox" ng-model="aaa">
<select>
	<option>111111111</option>
	<option ng-selected="aaa">222222222</option>
</select>
（提示：checkbox选框如果被选中时，它的selected为true，这个时候，222就会被选中）

[2]ng-change		input输入框内容变化时的关联指令，需要写ng-model="xxx"去触发
<input type="text" ng-change="events()" ng-model="aaa">

[3]ng-copy		input输入框内复制时的触发指令，不需要写ng-model="xxx"去触发
<input type="text" ng-copy="events()">

[4]ng-cut		input输入框内剪切时的触发指令，不需要写ng-model="xxx"去触发
<input type="text" ng-cut="events()">

[5]ng-paste		input输入框内粘贴时的触发指令，不需要写ng-model="xxx"去触发
<input type="text" ng-paste="events()">


-----------------------------------【input标签指令系统】-----------------------------------
1、ng-disabled	和原生的css属性disabled是一样的效果（禁用input标签等）
$scope.isDisabled=true;
<input type="button" ng-disabled="isDisabled">

2、$interval	和原生的setInterval是一样的效果,记得在angular的controller函数里面给他加上参数$interval
var num=0;
var timer=$interval(function(){
	num++;			
},1000);

它的清除方法为：$interval.cancel(timer);

[实例]5s后，button按钮可以点击
<script>
	var m1=angular.module('myApp',[]);
	m1.controller('Aaa',['$scope','$interval',function($scope,$interval){
		var iNow=5;
		$scope.data=iNow+'秒';
		$scope.isDisabled=true;
		var timer=$interval(function(){
			iNow--;
			$scope.data=iNow+'秒';
			if(iNow==0){
				$interval.cancel(timer);
				$scope.data='可以点击';
				$scope.isDisabled=false;
			};
		},1000);
	}]);
</script>
<div ng-controller="Aaa">
	<input type="button" value="{{data}}" ng-disabled="isDisabled">
</div>

3、ng-readonly		文本输入框禁用指令 ng-disabled同样可以禁用type='text'的input
<input type="text" value="5秒后可以输入" ng-readonly='isDisabled'>

4、ng-checked		单选或复选框的选中指令

5、ng-value		其实和input的value值是一样的，但是建议用ng-value去显示input的value值
<input type="button" ng-value="data" ng-disabled="isDisabled">

-----------------------------------【其他指令系统 属性指令：ng-xxx】-----------------------------------
1、ng-bind
2、ng-bind-template
3、ng-cloak
4、ng-non-bindable
5、ng-class
6、ng-style
7、ng-href
8、ng-src
9、ng-attr-(suffix)
10、ng-show
11、ng-hide
12、ng-if
13、ng-switch	-on	-default	-when
14、ng-open
15、ng-init(初始化)
16、ng-model-options
17、controller(中的面向对象写法 as)

1、ng-bind	html元素内容的替代指令
<p>{{text}}</p>
<p ng-bind="text"></p>
(提示：上面两种形式都是输入text内容，但是下面那种在页面加载时，如果加载比较慢的话，p标签里面的内容为空，提升用户体验)

2、ng-bind-template	支持多个内容输出
<p>{{text}},{{text}}</p>
<p ng-bind-template="{{text}},{{text}}"></p>
(提示：上面两种形式都是输入text内容，因为ng-bind不能同时输出多个值，所以只能用ng-bind-template)

3、ng-cloak	它和上面的方式效果一样，但是显示方式不一样而已（通过控制display）
<p ng-cloak>{{text}}</p>
(意思为，在没有解析完成之前先隐藏p标签，解析完成后再显示p标签，用户在加载没有完成时同样看不到数据)

4、ng-non-bindable	就是想解析成{{text}}这个数据
<p ng-non-bindable>{{text}}</p>		//{{text}}

5、ng-class	动态修改class
<style>
	.red{ background: red; }
	.yellow{ background: yellow; }
</style>
<p ng-class="{red:true,yellow:flase}">{{text}}</p>

6、ng-style	写style样式
<p ng-style="{color:'red',background:'#333'}">{{text}}</p>

或者写成这样：
$scope.style="{color:'red',background:'#333'}";
<p ng-style="{{style}}">{{text}}</p>

9、ng-attr-xxx	这是一种通用的写法，可以写任何html里面的属性,如果你不用数据绑定的形式时，记得加引号 ''
<p ng-attr-title="{{text}}">{{text}}</p>
<p ng-attr-title="{{'title属性'}}">{{text}}</p>
<p ng-attr-class="{{text}}">{{text}}</p>
<img ng-attr-src="{{'imgSrc'}}">

10、ng-show	显示或隐藏元素,操作css样式
<p ng-show="true">pppp</p>	//显示
<p ng-show="false">pppp</p>	//隐藏

[实例]复选框选中时显示p标签，否则隐藏p标签
$scope.anbtn=true;
<input type="checkbox" ng-model="anbtn">
<p ng-show="anbtn">pppp</p>

11、ng-hide	与上面相反

12、ng-if	添加或删除节点
<p ng-if="true">pppp2</p>	//添加节点
<p ng-if="false">pppp2</p>	//删除节点

13、ng-switch	复选框默认显示第一个p标签，为false时显示第二个p标签
$scope.btn=true;
<input type="checkbox" ng-model="btn">
<div ng-switch on="btn">
	<p ng-switch-default>默认效果</p>
	<p ng-switch-when="false">切换效果</p>
</div>

14、ng-open	HTML5标签details用的，不做介绍，有兼容问题

15、ng-model-options  (当input框失去焦点时改变数据)
<input type="text" ng-model="name" ng-model-options="{updateOn:'blur'}">
<P>{{name}}</P>

17、当angular对象下面controller中的属性和方法比较多的时候可以这样写
<script>
	var m1=angular.module('myApp',[]);
	m1.controller('Aaa',['$scope',FnAaa]);
	function FnAaa($scope){};
	FncAaa.prototype.name="hello";
</script>
<body>
	<div ng-controller="Aaa as FnAaa">
		<P>{{FnAaa.name}}</P>
	</div>
</body>

-----------------------------------【其他指令系统 标签指令：ng-xxx】-----------------------------------
angularJS对某些原有的html标签上做了升级处理，让他们具备某些功能
1、<a>
2、<select>
3、<textarea>
4、<input>
5、<form>


1、<a>标签
<div ng-app="myApp" ng-controller="Aaa">
	<a href="">aaaaa</a>
</div>
被ng-app作用到的a标签，都是经过处理的，angularjs都阻止了a标签的默认行为。
为什么要在a标签的href值不做跳转时阻止它的默认行为呢？因为
01--href不做跳转时点击a标签会刷新当前页面
02--在IE低版本下，点击会听到讨厌的“咔~ 咔~”的声音
03--阻止了a标签自带的锚点功能

2、<select>	配合ng-options 和 ng-model使用才生效
$scope.colors=[数据];
<select ng-options="color.name for color in colors" ng-model="myColor"></select>

5、<form>	novalidate属性：阻止表单元素默认行为
<form novalidate>
	<input type="email">
</form>		
(提示：在火狐下，表单元素验证不通过时，input会多出红色边框)


-----------------------------------【angularJS表单验证】-----------------------------------
1、$valid	$invalid
2、$pristine	$dirty
3、$error
注意点：
--name的方式进行查找
--要写ng-model

1---$valid	有效的：表单验证通过时为true，否则为false
2---$invalid	无效的：表单验证失败时为true，否则为false
3---$pristine	原始值：要是验证的值没有修改过的话为true，否则为false
4---$dirty	修改值：要是验证的值被修改过了的话为true，否则为false
5---$error	验证信息：不管是验证通过或失败，里面的信息都保存在了它这里

<form novalidate name="myForm">
	<input type="email" name="myText" ng-model="text">
	<div>{{ myForm.myText.$valid }}</div>
	<div>{{ myForm.myText.$invalid }}</div>
	<div>{{ myForm.myText.$pristine }}</div>
	<div>{{ myForm.myText.$dirty }}</div>
</form>

[实例]实时表单验证
$scope.fn1=function(){
	console.log('验证通过执行函数');
}；
$scope.fn2=function(){
	console.log('验证失败执行函数');
}；
<form novalidate name="myForm">
	<input type="email" name="myText" ng-model="text">
	<div>{{ myForm.myText.$valid?fn1():fn2() }}</div>
</form>


[表单元素的属性1]
1---required	input内容是否为空，为空时为true
<input type="text" name="myText" ng-model="text" required>
$error返回值：{"required":false}

2---ng-minlength='数字'		//最小长度
input输入框的内容长度超过你设定的数字时，$error返回false
$error返回值：{"minlength":false}

3---ng-maxlength='数字'		//最大长度

4---ng-pattern='正则表达试'
<input type="text" name="myText" ng-model="text" ng-pattern="/^[a-zA-Z]+$/">
匹配成功  $error返回值：{"pattern":false}

[表单元素的属性2]动态添加class
1、ng-valid{}
2、ng-invalid{}
3、ng-pristine{}
4、ng-dirty{}

[实例]验证通过和失败angularJs会给元素自动添加指定的class名
<style>
	input.ng-valid{ background:blue; }
	input.ng-invalid{ background:red; }
</style>
<form novalidate name="myForm">
	<input type="text" name="myText" ng-model="text" ng-pattern="/^[a-zA-Z]+$/">
</form>


-----------------------------------【angularJS自定义指令系统】-----------------------------------
【1】angular.module()---模块对象下面的四个方法：
1---controller：局部
2---run：全局  
3---filter：自定义过滤器
4---directive：自定义指令


自定义指令directive的创建方法：

1---自定义标签指令系统：restrict:'E' (用处：标签的替代方法)
var m1=angular.module('myApp',[]);
m1.directive('myElement',fucntion(){		//myElement就是自己起的名字,但在html里面要写成my-element
	return {
		restrict:'E',			//E代表标签指令
		template:'<p>hello</p>' 	//模板指令--相当于添加到标签里面的结构数据
	}	
})
<body>
	<my-element></my-element>    相当于在html里面有这样的结构：<my-element><p>hello</p></my-element>
</body>

2---自定义属性指令系统：restrict:'A' (用处：添加独特的属性方法，比如ng-show这样的angular自带属性，并且它兼容IE8)	
var m1=angular.module('myApp',[]);
m1.directive('myElement',fucntion(){		//myElement就是自己起的名字,但在html里面要写成my-element
	return {
		restrict:'A',			//A代表属性指令
		template:'<p>hello</p>' 	//模板指令--相当于添加到标签里面的结构数据
	}	
})
<body>
	<div my-element></div>	相当于在html里面有这样的结构：<div my-element=“”><p>hello</p></div>
</body>

3---替换指令系统：replace:true (用处：标签的替代方法)
var m1=angular.module('myApp',[]);
m1.directive('myElement',fucntion(){		//myElement就是自己起的名字,但在html里面要写成my-element
	return {
		restrict:'E',			//E代表标签指令
		replace:true,			//替换指令
		template:'<p>hello</p>' 	//模板指令--相当于添加到标签里面的结构数据
	}	
})
<body>
	<my-element></my-element>    相当于在html里面有这样的结构：<p>hello</p>
	<div my-element></div>       相当于在html里面有这样的结构：<p my-element>hello</p>
</body>

4---替换html结构指令系统：templateUrl:"页面名.html"(有兼容问题：建议在服务环境下用)
var m1=angular.module('myApp',[]);
m1.directive('myElement',fucntion(){		//myElement就是自己起的名字,但在html里面要写成my-element
	return {
		restrict:'E',			//E代表标签指令
		replace:true,			//替换指令
		templateUrl:"页面名.html"	//templateUrl替换了template，而 页面名.html 这个html里面，只需要写结构就可以了，不需要写其他的html标签
	}	
})
<body>
	<my-element></my-element>    相当于在当前html里面有结构 页面名.html 的结构
</body>

5---注释指令系统：restrict:'M'  (用得很少)
var m1=angular.module('myApp',[]);
m1.directive('myElement',fucntion(){		//myElement就是自己起的名字,但在html里面要写成my-element
	return {
		restrict:'EM',			//E代表标签指令
		replace:true,			//替换指令
		template:'<p>hello</p>' 	//模板指令--相当于添加到标签里面的结构数据
	}	
})
<body>
	<!-- directive:my-element -->   相当于在html里面有这样的结构：<p>hello</p>
</body>

(提示1：restrict它的value值是可以组合使用的，如：restrict:'AE',这样就代表你创建的指令既是标签指令，又是属性指令)

6---directive的独立作用域：scope:true/false
var m1=angular.module('myApp',[]);
m1.controller('Aaa',['$scope',function($scope){
	$scope.name='hello';
}]);
m1.directive('myElement',fucntion(){		//myElement就是自己起的名字,但在html里面要写成my-element
	return {
		restrict:'E',			//E代表标签指令
		replace:true,			//替换指令
		scope:true,			//默认为false(公用数据),true(可以开辟新的作用域,来独享数据)
		template:'<p>{{name}}</p>' 	//模板指令--相当于添加到标签里面的结构数据
	}	
})
<body ng-controller="Aaa">
	<my-element></my-element>   			<p>hello</p>
	<my-element ng-init="name='hi'"></my-element>	<p>hi</p>
</body>

7---directive的隔离作用域：scope:{}  绑定策略的三种形式：@ 、= 、&。
(意思为,不在受到 ng-controller="Aaa"的作用，它里面的name数据也不会继承Aaa函数里面的数据,而是要通过另一conterller去绑定数据)
var m1=angular.module('myApp',[]);
m1.controller('Aaa',['$scope',function($scope){
	$scope.name='hello';
}]);
m1.directive('myElement',fucntion(){		
	return {
		restrict:'E',			
		replace:true,			
		scope:{},	
		controller:['$scope',funciton($scope){
			$scope.name='hhhi';		//这里面都是公用的数据
		}],		
		template:'<p id="div">{{name}}</p>' 	
	}	
})
<body ng-controller="Aaa">
	<my-element></my-element>   	<p id="div">hhhi</p>
	<my-element></my-element>	<p id="div">hhhi</p>
</body>

8---上面的结构出现了一样的id名 id="div" 这是不对的，解决方法 scope里面去写参数 myId:'@'
var m1=angular.module('myApp',[]);
m1.directive('myElement',fucntion(){		
	return {
		restrict:'E',			
		replace:true,			
		scope:{
			myId:'@'			//myId就相当于my-id 等于你绑定的值,并且只作用在当前directive里面
		},	
		controller:['$scope',funciton($scope){
			$scope.name='hhhi';		//这里面都是公用的数据
		}],		
		template:'<p id="{{myId}}">{{name}}</p>' 	
	}	
})
<body>
	<my-tab my-id="div1"></my-tab> 		<p id="div1" my-id="div1">hhhi</p>
	<my-tab my-id="div2"></my-tab>		<p id="div2" my-id="div2">hhhi</p>
</body>

9---'=' 获取父级的数据
var m1=angular.module('myApp',[]);
m1.controller('Aaa',['$scope',function($scope){
	$scope.name='hello';
}]);
m1.directive('myTab',function(){
	return {
		restrict:'E',
		replace:true,
		scope:{
			myId:'@',		//myId就相当于my-id 等于你绑定的值,并且只作用在当前directive里面
			myName:'='		//它代表数据,只作用与父级<body ng-controller="Aaa">里面，所以myName=$scope.name='hello'
		},
		controller:['$scope',function($scope){
			$scope.name="hhhi";
		}],
		template:'<p id="{{myId}}">{{myName}}</p>' 
	}
});
<body ng-controller="Aaa">
	<my-tab my-id="div1" my-name="name"></my-tab>	<p id="div1" my-id="div1" my-name="name">hello</p>
	<my-tab my-id="div2" my-name="name"></my-tab>	<p id="div1" my-id="div1" my-name="name">hello</p>
</body>


10---myFn:'&' 执行父级数据里面的函数
var m1=angular.module('myApp',[]);
m1.controller('Aaa',['$scope',function($scope){
	$scope.name='hello';
	$scope.show=function(){alert(1)};
}]);
m1.directive('myTab',function(){
	return {
		restrict:'E',
		replace:true,
		scope:{
			myId:'@',		//myId就相当于my-id 等于你绑定的值,并且只作用在当前directive里面
			myName:'=',		//它代表数据,只作用与父级<body ng-controller="Aaa">里面，所以myName=$scope.name='hello'
			myFn:'&'		//它代表执行父级数据里面的函数
		},
		controller:['$scope',function($scope){
			$scope.name="hhhi";
		}],
		template:'<p id="{{myId}}" ng-click="myFn()">{{myName}}</p>' 
	}
});
<body ng-controller="Aaa">
	<my-tab my-id="div1" my-name="name" my-fn="show()"></my-tab>	<p id="div1" my-id="div1" my-name="name" ng-click="myFn()">hello</p>
	<my-tab my-id="div2" my-name="name" my-fn="show()"></my-tab>	<p id="div1" my-id="div1" my-name="name" ng-click="myFn()">hello</p>
</body>

【总结】绑定策略的三种形式：@ 、= 、&。
@：单向引用父域的值，传递的值必须是“字符串”且在指令里引用时必须加上{{}}；

=：双向绑定子域和父域；是针对某个对象数据的引用

&：单向绑定父域，以便在其中运行函数



【angularJS自定义指令系统：DOM操作】：link  (接受4个参数)
link:function(scope,element,attr,reController){}
1---scope:作用域
2---element:最外层的父级元素(可以引入jq去做配合,利用jq的事件绑定delegate去做事件的处理)
3---attr:最外层的父级元素的属性
4---reController:通过模板传递require去获取上一层数据

link:function(scope,element,attr,reController){
	console.log(scope.name);
	console.log(element);
	console.log(attr);
}


【实例1：利用自定义标签指令E，做一个选项卡】
	<script>
		var m1=angular.module('myApp',[]);
		m1.controller('Aaa', ['$scope', function($scope){
			$scope.data1=[
				{title:'数学',content:'数学'},
				{title:'语文',content:'语文'},
				{title:'英语',content:'英语'}
			];
			$scope.data2=[
				{title:'物理',content:'物理'},
				{title:'化学',content:'化学'}
			];
		}]);
		m1.directive('myTab',function(){
			return {
				restrict:'E',
				replace:true,
				scope:{
					myId:'@',
					myEvent:'@',	//可以不写这个，attr也能找到(在link里面的属性不用映射到scope里面)
					myData:'='
				},
				template:'<div id="{{myId}}" class="tabwrap">\
					<input ng-repeat="data in myData" type="button" ng-value="data.title" ng-class="{input_active:$first}">\
					<div ng-repeat="data in myData" ng-class="{div_active:$first}" ng-bind="data.content"></div>\
				</div>',
				link:function(scope,element,attr,reController){
					element.delegate('input', attr.myEvent, function(event) {
						var indexs=$(this).index();
						element.find('.btn').removeClass('input_active');
						element.find('.div').removeClass('div_active');
						$(this).addClass('input_active');
						element.find('.div').eq(indexs).addClass('div_active');
					});
				}

			}
		});
	</script>
</head>
<body ng-controller="Aaa">
	<my-tab my-id="div1" my-data="data1" my-event="click"></my-tab>
	<my-tab my-id="div2" my-data="data2" my-event="mouseover"></my-tab>
</body>
</html> 

【实例2：利用自定义属性指令A，做一个拖拽】
记事本记录。


【angularJS自定义指令系统：不同自定义指令之间的交互】
1---transclude:true  不同自定义模板之间的嵌套处理

m1.directive('hello',function(){
	return {
		restrict:'E',
		replace:true,
		transclude:true,	//transclude是一个可选的参数。如果设置了,其值必须为true,它的默认值是false。
		template:'<div>hello <h1 ng-transclude></h1></div>'
	}
});
m1.directive('hi',function(){
	return {
		restrict:'E',
		replace:true,
		template:'<span>hi</span>'
	}
});
......
<body>
	<hello>
		<hi></hi>	//<div>hello <h1 ng-transclude><hi></hi></h1></div>
	</hello>
</body>
(给一个元素加上ng-transclude后，它就会把<hello>里面的全部自定义标签或属性放在<h1 ng-transclude></h1>里面，而不造成覆盖)

2---不同自定义指令系统--操作指定父层数据：
m1.directive('hello',function(){
	return {
		restrict:'E',
		replace:true,
		transclude:true,
		controller:function($scope){
			$scope.name='小米';	//$scope开头只能在hello模板里面自己用
			this.name='小明';	//this开头可以运用模板数据传递require去获取，保证其他自定义指令系统都能获取到
		},	
		template:'<div>hello <h1 ng-transclude></h1></div>'
	}
});
m1.directive('hi',function(){
	return {
		restrict:'E',
		replace:true,
		template:'<span>hi</span>'
		require:'?^hello',		//^hello上一层父级模板 加‘？’是一种容错处理，没有数据的话不会报错
		link:function(scope,element,attr,reController){
			console.log(reController.name)   //小明
		}
	}
});
......
<body>
	<hello>
		<hi></hi>	//<div>hello <h1 ng-transclude><hi></hi></h1></div>
	</hello>
</body>


-----------------------------------【angularJS的ajax服务:$http】-----------------------------------
【1】定义：$http服务直接同外部进行通信。$http服务只是简单的封装了浏览器原生的XMLHttpRequest对象。类似于原生js的ajax
1---链式调用：
var m1=angular.module('myApp',[]);
m1.controller('Aaa',['$scope','$http',function($scope,$http){
	$http({
		method:'GET',		//方式方式
		url:'data1.php'		//请求地址
	}).error(function(data,header,config,status){
		alert('请求失败')
	}).success(function(data,state,headers,config){
		console.log(data)	//数据
		console.log(state)	//状态 成功是200，失败是300
		console.log(header)	//
		console.log(config)	//
	})
}]);
(提示：也支持简写方式，比如 $http.get('data.php').success(function(data,state,headers,config){xxx}) );

【实例:仿百度搜索JSONP请求】
<script>
var m1=angular.module('myApp',[]);
m1.controller('Aaa',['$scope','$http','$timeout',function($scope,$timeout,$http){	
	var timer=null;				
	$scope.dataList=[];				//保存请求成功后的数据
	$scope.change=function(name){
		$timeout.cancel(timer);
		timer=$timeout(function(){		//$timeout做延迟处理，提高效率
			$http({				//JSON_CALLBACK 为angularJs提供的回掉，要把从网上拿的最后的回调改成这个即可
				method:'JSONP',
				url:'https://www.baidu.com/his?wd='+name+'&cb=JSON_CALLBACK' //JSONP地址 	
			}).error(function(data,state,headers,config){
				alert('请求失败')
			}).success(function(data,state,headers,config){
				console.log(data)
				$scope.dataList=data;	//保存请求成功后的数据
			});
		},300);
	};
}]);
</script> 
<div ng-controller="Aaa">
	<input type="text" class="input" ng-model="name" ng-keyup="change(name)">
	<button type="button" class="btn" ng-click="change(name)">搜索</button>
	<ul class="ul">
		<li ng-repeat="data in dataList">{{data}}</li>
	</ul>
</div>

【实例：发送数据到后台】

//通过post传递的参数
var data = {
	pageindex: 1,
	pagesize: 8,
};

//post请求的地址
var url = "/admin/KeyValue/GetListByPage";

//将参数传递的方式改成form
var postCfg = {
	headers: { 'Content-Type': 'application/x-www-form-urlencoded' },
	transformRequest: function (data) {
		return $.param(data);
	}
};

//发送post请求，获取数据
$http.post(url,data,postCfg)
	.success(function (data,state,headers,config) {
	alert("成功");
});


-----------------------------------【angularJS的服务:$location】-----------------------------------
[1]--$location 服务分析浏览器地址栏中的 URL （基于 window.location ），让我们可以在应用中较为方便地使用 URL 里面的东东。
在地址栏中更改 URL ，会响应到 $location 服务中，而在 $location 中修改 URL ，也会响应到地址栏中。

[2]--$location 服务：
1---暴露当前浏览器地址栏的 URL ，所以我们可以
注意和观察 URL   改变 URL

2---当用户做以下操作时，与浏览器一起同步 URL ：
改变地址栏  单击后退或者前进按钮（或者点击一个历史链接） 单击一个链接

3---将 URL 对象描绘为一系列的方法（ protocol ， host ， path ， search ， hash ）。
1.比较 $location 和 window.location

2.目的： window.location 和 $location 服务，都允许对当前浏览器的 location 进行读写访问。

[3]---$location下面的方法：
1---$location.absUrl();		//得到浏览器地址栏里面的路径
2---$location.path();		//做路由操作的 
    $location.path('aaa');	//浏览器地址栏里面的路径改变成  地址#/aaa
3---$location.hash('aaa');	//hash值  地 址#/aaa
4---$location.search({age:20});	//search值的设置  ?age=20
5---$location.url();		//获取路径后面的hash值和search值和path值
6---$location.host();		//主机名
7---$location.port();		//端口号
8---$location.protocol();	//协议 一般都是http协议


-----------------------------------【angularJS的服务:$anchorScroll】-----------------------------------
【$anchorScroll】瞄点跳转:angularJs会阻止a标签原有的瞄点跳转功能
<script>
	var m1=angular.module('myApp',[]);
	m1.controller('Aaa',['$scope','$location','$anchorScroll',function($scope,$location,$anchorScroll){	
		$scope.change=function(id){
			$location.hash(id);	//改变hash去做跳转当前页面位置和a的href瞄点跳转是一样的
			$anchorScroll();	//重置瞄点
		};
	}]);
</script>
<div class="wrap">
	<ul>
		<li ng-repeat="id in [1,2,3,4,5]" ng-click="change('div'+id)">{{id}}点击跳转到瞄点</li>
	</ul>
	<div ng-repeat="id in [1,2,3,4,5]" ng-attr-id="div{{id}}">{{id}}</div>
</div>


-----------------------------------【angularJS的服务:$cacheFactory】------------------------------------
【1】定义i：用于生成一个用来存储缓存对象的服务，并且提供对对象的访问。
var cache=$cacheFactory('名字');

1---cache.info():缓存对象信息
var cache=$cacheFactory('myCache');
console.log(cache.info());	//object{ id:myCache,size:缓存长度 }

2---cache.put():设置缓存对象
var cache=$cacheFactory('myCache');
cache.put('key值','value值');
console.log(cache.info());	//object{ id:myCache,size:1 }

3---cache.get('key值'): 获取缓存对象
在缓存对象中通过指定key获取对应的值

4---cache.romove(key值): 删除缓存对象对应的值
在缓存对象中通过指定key删除对应的值。

5---cahce.removeAll(): 删除缓存对象所有值
删除缓存对象中所有的键值对

6---destroy(): 销毁这个缓存对象

7---capacity:设置缓存长度
var cache=$cacheFactory('myCache'，{capacity:数字});

注意：key：string类型，缓存对象中的值名称。
      value：所有类型，缓存对象中的值。

-----------------------------------【angularJS的服务:$interpolate】------------------------------------
【1】插值服务:在textarea里面输入{{name}}可以打印input里面的value值
var m1=angular.module('myApp',[]);
m1.controller('Aaa',['$scope','$interpolate',function($scope,$interpolate){	
	$scope.$watch('inter',function(news){
		if(news){
			var polate=$interpolate(news);
			$scope.interText=polate({name:$scope.name})
		};
	});
}]);

<body ng-controller="Aaa">
	<input type="text" ng-model="name">
	<textarea ng-model="inter"></textarea>
	<p>{{interText}}</p>
</body>


-----------------------------------【angularJS的服务:$q】------------------------------------
【1】$q就是一种对执行结果不确定的一种预先定义，如果成功，就xxxx；如果失败，就xxxx，就像事先给出了一些承诺。
1---defer() 创建一个deferred对象，这个对象可以执行几个常用的方法，比如resolve,reject,notify等
	var defers=$q.defer();	//创建一个deferred对象
	function show(){
		setTimeout(function(){
			defers.resolve(); //成功指令
			defers.reject();  //失败指令
			defers.notify();  //实时指令
		}, 1000);
		return defers.promise; //返回promise对象
	};
	show().then(function(){
		console.log('成功')
	},function(){
		console.log('失败')
	});
	

2---all()  传入Promise的数组，批量执行，返回一个promise对象
3---when() 传入一个不确定的参数，如果符合Promise标准，就返回一个promise对象。


-----------------------------------【angularJS的供应商:m1.config】------------------------------------
【1】angularJs中服务对应的供应商：服务名称+Provider 
var m1=angular.module('myApp',[]);
m1.config(['$interpolateProvider',function($interpolateProvider){
	$interpolateProvider.startSymbol('@@'); //改变开始 {{
	$interpolateProvider.endSymbol('@@');	//改变结尾 }}
}]);
m1.controller('Aaa',['$scope','$interpolate',function($scope,$interpolate){	
	$scope.name="hello";
}]);
<body ng-controller="Aaa">
	<p>@@name@@</p>
</body>
(它可以对angularJS的服务做初始化时做基本配置,还有其他的服务对应的供应商)


-----------------------------------【angularJS自定义服务:factory&&service】------------------------------------
【简介】当你初试 Angular 时，很自然地就会往 controller 和 scope 里堆满不必要的逻辑。一定要早点意识到，controller 这一层应该很薄；
也就是说，应用里大部分的业务逻辑和持久化数据都应该放在 service 里。
【1】不同作用域下面共享数据方式1：factory()
var m1=angular.module('myApp',[]);
m1.factory('myFuwu',function(){
	return {
		name:'hello',
		show:function(){
			return this.name;
		}
	}
});
m1.controller('Aaa',['$scope','myFuwu',function($scope,myFuwu){
	console.log( myFuwu.show() )
}]);

【2】不同作用域下面共享数据方式2：service()
var m1=angular.module('myApp',[]);
m1.service('myData',function(){
	return [
		{
			name:'小明',
			age:10
		},
		{
			name:'小红',
			age:20
		},
		{
			name:'小李',
			age:30
		}
	]
});
m1.controller('Aaa',['$scope','myData',function($scope,myData){
	$scope.data=myData;
}]);
m1.controller('Bbb',['$scope','myData',function($scope,myData){
	$scope.data=myData;
}]);

(注意：
	1--自定义服务名称不要以$开头,并且在引用时最好在angualrjs自带服务的后面去应用
	2--factory方法可以返回任何类型的数据，service只能返回对象数据
)

-----------------------------------【angularJS插件：ngRoute】------------------------------------
【提示】在引入angularjs的一些插件的时候，注意下版本问题，如果 angular.min.js或者angular.js的版本和插件的版本开发时间差异比较
大时，可能会出现报错情况。

【1】插件：ngRoute(路由切换)
1---ng-view:切换主体内容

[实例1]:点击下面的a链接，在当前页面做不同内容的渲染
<script src="./js/angular.min.js"></script>
<script src="http://cdn.bootcss.com/angular.js/1.2.9/angular-route.min.js"></script>
<script>
	var m1=angular.module('myApp',['ngRoute']);
	m1.controller('Aaa',['$scope',function($scope){
		xxxxx	
	}]);
	m1.config(['$routeProvider',function($routeProvider) {	//服务供应商
		$routeProvider
			.when('/aaa',{
				template:'<p>aaaa</p>'    //或者调用templateUrl
			})
			.when('/bbb',{
				template:'<p>bbbb</p>'    //或者调用templateUrl
			})
			.when('/ccc',{
				template:'<p>cccc</p>'    //或者调用templateUrl
			})
			.otherwise({			  //路由初始渲染页面，或页面报错时渲染页面
				redirectTo:'/aaa' 
			})
	}]);
</script> 
<body ng-controller="Aaa">
	<a href="#aaa">页面1</a>
	<a href="#bbb">页面2</a>
	<a href="#ccc">页面3</a>
	<div ng-view></div>
</body>

(提示：当点击a链接时，就相当于把template里面的内容添加到了<div ng-view></div>中，并且这个div中每次添加的时候都会先清空自己的内容,
并且这个插件是会主动添加历史管理的，页面刷新时，会依然显示当前停留页面)

[实例2]:点击下面的a链接，在当前页面做不同内容的渲染,并且数据不同
<script src="./js/angular.min.js"></script>
<script src="http://cdn.bootcss.com/angular.js/1.2.9/angular-route.min.js"></script>
<script>
	var m1=angular.module('myApp',['ngRoute']);
	m1.controller('Aaa',['$scope',function($scope){
		$scope.name='hello';
	}]);
	m1.controller('Bbb',['$scope',function($scope){
		$scope.name='hi';
	}]);
	m1.controller('Ccc',['$scope',function($scope){
		$scope.name='ha';
	}]);
	m1.config(['$routeProvider',function($routeProvider) {	   //服务供应商
		$routeProvider
			.when('/aaa',{
				template:'<p>aaaa {{name}}</p>'，  // 得到数据: aaa hello  
				controller:'Aaa'   
			})
			.when('/bbb',{
				template:'<p>bbbb {{name}}</p>',		   // 得到数据: bbb hi 
				controller:'Bbb'       
			})
			.when('/ccc',{
				template:'<p>cccc {{name}}</p>',		   // 得到数据: ccc ha 
				controller:'Ccc'    
			})
			.otherwise({			  
				redirectTo:'/aaa' 
			})
	}]);
</script> 
<body ng-controller="Aaa">
	<a href="#aaa">页面1</a>
	<a href="#bbb">页面2</a>
	<a href="#ccc">页面3</a>
	<div ng-view></div>
</body>


【2】插件：ngRoute(路由切换事件)
var m1=angular.module('myApp',['ngRoute']);	//也可以给$scope单独绑定
m1.run(['$rootScope',function($rootScope){
	$rootScope.$on('$routeChangeStart',function(event,current,pre){
		console.log('路由切换成功之前');
	});
	$rootScope.$on('$routeChangeError',function(event,current,pre){
		console.log('路由切换失败之后');
	});
}]);


-------------------------------------【angularJS插件：ngAnimate】------------------------------------
【插件】：ngAnimate(运动)，它有两种运动方式：
引入插件：<script src="http://cdn.bootcss.com/angular.js/1.2.9/angular-animate.min.js"></script>
使用插件：var m1=angular.module('myApp',['ngAnimate']);
注意：目前支持指令：if view repeat include swtich

【1】css3完成运动：只需要在特定元素上添加指定class即可完成运动

ng-enter		//进入起始样式
ng-enter-active		//进入结束样式

ng-leave		//离开起始样式
ng-leave-active		//离开结束样式

实例：div淡入淡出效果
<style>
	.divWrap{
		width: 200px;
		height: 200px;
		background: #333;
		transition: 1s all;		//设置运动时间
	}
	.divWrap.ng-enter{opacity: 0;}
	.divWrap.ng-enter-active{opacity: 1;}
	.divWrap.ng-leave{opacity: 1;}
	.divWrap.ng-leave-active{opacity: 0;} 
</style>
<script>
	var m1=angular.module('myApp',['ngAnimate']);
	m1.controller('Aaa',['$scope',function($scope){
		$scope.bBtn=true;
	}]);
</script>
<div ng-controller="Aaa">
	<input type="checkbox" ng-model="bBtn">
	<div class="divWrap" ng-if="bBtn"></div>
</div>
(提示：不是所有的angular指令都支持)

ng-repeat的有循序的运动：他在加载的时候会按写好的运动样式从第一个执行到最后一个
1---ng-enter-stagger{ animation-delay:100ms; }  //进入
1---ng-leave-stagger{ animation-delay:100ms; }	//离开
(提示：建议应用最新的版本)


【2】JS完成运动：animation()   要引入最新的版本和jq
<script src="../js/jquery-1.11.1.js"></script>
<script src="http://cdn.bootcss.com/angular.js/1.3.8/angular.min.js"></script>
<script src="http://cdn.bootcss.com/angular.js/1.3.8/angular-animate.min.js"></script>
1---针对 ng-if 指令：
<style>
	.divWrap{
		position: absolute;
		left: 20px;
		top: 40px;
		width: 400px;
		height: 400px;
		background: #333;
	}
</style>
<script>
	var m1=angular.module('myApp',['ngAnimate']);
	m1.controller('Aaa',['$scope',function($scope){
		$scope.bBtn=true;
	}]);
	m1.animation('.divWrap',function(){
		return{
			enter:function(element,done){		//进入
				$(element).css('opacity','0')
				$(element).animate({
					opacity:1
				},1000,done)
			},
			leave:function(element,done){		//离开
				$(element).animate({
					opacity:0
				},1000,done)
			}
		};
	});
</script>
<body ng-controller="Aaa">
	<input type="checkbox" ng-model="bBtn">
	<div class="divWrap" ng-if="bBtn"></div>
</body>

2---针对 ng-show 指令：
<style>
	.divWrap{
		position: absolute;
		left: 20px;
		top: 40px;
		width: 400px;
		height: 400px;
		background: #333;
	}
</style>
<script>
	var m1=angular.module('myApp',['ngAnimate']);
	m1.controller('Aaa',['$scope',function($scope){
		$scope.bBtn=true;
	}]);
	m1.animation('.divWrap',function(){
		return{
			removeClass:function(element,sClass,done){	//进入
				$(element).css('opacity','0')
				$(element).animate({
					opacity:1
				},1000,done)
			},
			addClass:function(element,sClass,done){		//离开
				$(element).animate({
					opacity:0
				},1000,done)
			}
		};
	});
</script>
<body ng-controller="Aaa">
	<input type="checkbox" ng-model="bBtn">
	<div class="divWrap" ng-show="bBtn"></div>
</body>


-------------------------------------【angularJS插件：ngResource】------------------------------------
简介：和$http服务一样，做ajax请求的，他可以处理复杂的ajax请求
(具体内容看资料)


-----------------------------------【angularJS事件的内部传播方式】------------------------------------
【1】相同数据，不同作用域下面的数据传播方式
var m1=angular.module('myApp',[]);
m1.controller('Aaa',['$scope',function($scope){
	$scope.count=0;
}]);
<body>
	<div ng-controller="Aaa">
		<h2>{{count}}</h2>
		<div ng-controller="Aaa" ng-click=" count=count+1 ">
			<h2>{{count}}</h2>
			<div ng-controller="Aaa">
				<h2>{{count}}</h2>
			</div>
		</div>
	</div>
</body>
(提示：点击第二个div时，只改变了当前自己作用域下面的$scope.count，不会影响其他作用域下的$scope.count的变化)


【2】相同数据，不同作用域下面的数据'向上'传播方式  $on与$emit('自定义名称')
var m1=angular.module('myApp',[]);
m1.controller('Aaa',['$scope',function($scope){
	$scope.count=0;
	$scope.$on('myEvent',function(){
		$scope.count++;
	});
}]);
<body>
	<div ng-controller="Aaa">
		<h2>{{count}}</h2>
		<div ng-controller="Aaa" ng-click=" $emit('myEvent') ">
			<h2>{{count}}</h2>
			<div ng-controller="Aaa">
				<h2>{{count}}</h2>
			</div>
		</div>
	</div>
</body>
(提示：点击第二个div时，改变了当前自己作用域下面的$scope.count和上一级作用域下面的$scope.count)

【3】相同数据，不同作用域下面的数据'向下'传播方式  $on与$broadcast('自定义名称')
<body>
	<div ng-controller="Aaa">
		<h2>{{count}}</h2>
		<div ng-controller="Aaa" ng-click=" $broadcast('myEvent') ">
			<h2>{{count}}</h2>
			<div ng-controller="Aaa">
				<h2>{{count}}</h2>
			</div>
		</div>
	</div>
</body>
(提示：点击第二个div时，改变了当前自己作用域下面的$scope.count和下一级作用域下面的$scope.count)



































